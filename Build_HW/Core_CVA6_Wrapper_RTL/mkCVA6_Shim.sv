//
// Generated by Bluespec Compiler, version 2023.01 (build 52adafa5)
// Then hand-edited to fill in the empty body of the module.
// Copyright (c) 2023 Rishiyur S. Nikhil and Bluespec, Inc.
//
//
// ****************************************************************
// Needed for types of various ports in cva6 instance

`include "CVA6_Files.vh"

// ****************************************************************

// Ports:
// Name                         I/O  size props
// axi4_m_awatop                  O     6 const
// axi4_m_awvalid                 O     1 const
// axi4_m_awid                    O    16 const
// axi4_m_awaddr                  O    64 const
// axi4_m_awlen                   O     8 const
// axi4_m_awsize                  O     3 const
// axi4_m_awburst                 O     2 const
// axi4_m_awlock                  O     1 const
// axi4_m_awcache                 O     4 const
// axi4_m_awprot                  O     3 const
// axi4_m_awqos                   O     4 const
// axi4_m_awregion                O     4 const
// axi4_m_wvalid                  O     1 const
// axi4_m_wdata                   O    64 const
// axi4_m_wstrb                   O     8 const
// axi4_m_wlast                   O     1 const
// axi4_m_bready                  O     1 const
// axi4_m_arvalid                 O     1 const
// axi4_m_arid                    O    16 const
// axi4_m_araddr                  O    64 const
// axi4_m_arlen                   O     8 const
// axi4_m_arsize                  O     3 const
// axi4_m_arburst                 O     2 const
// axi4_m_arlock                  O     1 const
// axi4_m_arcache                 O     4 const
// axi4_m_arprot                  O     3 const
// axi4_m_arqos                   O     4 const
// axi4_m_arregion                O     4 const
// axi4_m_rready                  O     1 const
// CLK                            I     1 unused
// RST_N                          I     1 unused
// boot_addr_i                    I    64 unused
// hart_id_i                      I    64 unused
// irq_i                          I     1 unused
// ipi_i                          I     1 unused
// time_irq_i                     I     1 unused
// axi4_m_awready                 I     1 unused
// axi4_m_wready                  I     1 unused
// axi4_m_bvalid                  I     1 unused
// axi4_m_bid                     I    16 unused
// axi4_m_bresp                   I     2 unused
// axi4_m_arready                 I     1 unused
// axi4_m_rvalid                  I     1 unused
// axi4_m_rid                     I    16 unused
// axi4_m_rdata                   I    64 unused
// axi4_m_rresp                   I     2 unused
// axi4_m_rlast                   I     1 unused
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkCVA6_Shim(CLK,
		   RST_N,

		   boot_addr_i,

		   hart_id_i,

		   irq_i,

		   ipi_i,

		   time_irq_i,

		   axi4_m_awatop,

		   axi4_m_awvalid,

		   axi4_m_awid,

		   axi4_m_awaddr,

		   axi4_m_awlen,

		   axi4_m_awsize,

		   axi4_m_awburst,

		   axi4_m_awlock,

		   axi4_m_awcache,

		   axi4_m_awprot,

		   axi4_m_awqos,

		   axi4_m_awregion,

		   axi4_m_awready,

		   axi4_m_wvalid,

		   axi4_m_wdata,

		   axi4_m_wstrb,

		   axi4_m_wlast,

		   axi4_m_wready,

		   axi4_m_bvalid,
		   axi4_m_bid,
		   axi4_m_bresp,

		   axi4_m_bready,

		   axi4_m_arvalid,

		   axi4_m_arid,

		   axi4_m_araddr,

		   axi4_m_arlen,

		   axi4_m_arsize,

		   axi4_m_arburst,

		   axi4_m_arlock,

		   axi4_m_arcache,

		   axi4_m_arprot,

		   axi4_m_arqos,

		   axi4_m_arregion,

		   axi4_m_arready,

		   axi4_m_rvalid,
		   axi4_m_rid,
		   axi4_m_rdata,
		   axi4_m_rresp,
		   axi4_m_rlast,

		   axi4_m_rready);
  input  CLK;
  input  RST_N;

  // action method m_boot_addr
  input  [63 : 0] boot_addr_i;

  // action method m_hart_id
  input  [63 : 0] hart_id_i;

  // action method m_irq_external
  input  irq_i;

  // action method m_irq_software
  input  ipi_i;

  // action method m_irq_timer
  input  time_irq_i;

  // value method axi4_m_awatop
  output [5 : 0] axi4_m_awatop;

  // value method axi4_m_m_awvalid
  output axi4_m_awvalid;

  // value method axi4_m_m_awid
  output [15 : 0] axi4_m_awid;

  // value method axi4_m_m_awaddr
  output [63 : 0] axi4_m_awaddr;

  // value method axi4_m_m_awlen
  output [7 : 0] axi4_m_awlen;

  // value method axi4_m_m_awsize
  output [2 : 0] axi4_m_awsize;

  // value method axi4_m_m_awburst
  output [1 : 0] axi4_m_awburst;

  // value method axi4_m_m_awlock
  output axi4_m_awlock;

  // value method axi4_m_m_awcache
  output [3 : 0] axi4_m_awcache;

  // value method axi4_m_m_awprot
  output [2 : 0] axi4_m_awprot;

  // value method axi4_m_m_awqos
  output [3 : 0] axi4_m_awqos;

  // value method axi4_m_m_awregion
  output [3 : 0] axi4_m_awregion;

  // value method axi4_m_m_awuser

  // action method axi4_m_m_awready
  input  axi4_m_awready;

  // value method axi4_m_m_wvalid
  output axi4_m_wvalid;

  // value method axi4_m_m_wdata
  output [63 : 0] axi4_m_wdata;

  // value method axi4_m_m_wstrb
  output [7 : 0] axi4_m_wstrb;

  // value method axi4_m_m_wlast
  output axi4_m_wlast;

  // value method axi4_m_m_wuser

  // action method axi4_m_m_wready
  input  axi4_m_wready;

  // action method axi4_m_m_bvalid
  input  axi4_m_bvalid;
  input  [15 : 0] axi4_m_bid;
  input  [1 : 0] axi4_m_bresp;

  // value method axi4_m_m_bready
  output axi4_m_bready;

  // value method axi4_m_m_arvalid
  output axi4_m_arvalid;

  // value method axi4_m_m_arid
  output [15 : 0] axi4_m_arid;

  // value method axi4_m_m_araddr
  output [63 : 0] axi4_m_araddr;

  // value method axi4_m_m_arlen
  output [7 : 0] axi4_m_arlen;

  // value method axi4_m_m_arsize
  output [2 : 0] axi4_m_arsize;

  // value method axi4_m_m_arburst
  output [1 : 0] axi4_m_arburst;

  // value method axi4_m_m_arlock
  output axi4_m_arlock;

  // value method axi4_m_m_arcache
  output [3 : 0] axi4_m_arcache;

  // value method axi4_m_m_arprot
  output [2 : 0] axi4_m_arprot;

  // value method axi4_m_m_arqos
  output [3 : 0] axi4_m_arqos;

  // value method axi4_m_m_arregion
  output [3 : 0] axi4_m_arregion;

  // value method axi4_m_m_aruser

  // action method axi4_m_m_arready
  input  axi4_m_arready;

  // action method axi4_m_m_rvalid
  input  axi4_m_rvalid;
  input  [15 : 0] axi4_m_rid;
  input  [63 : 0] axi4_m_rdata;
  input  [1 : 0] axi4_m_rresp;
  input  axi4_m_rlast;

  // value method axi4_m_m_rready
  output axi4_m_rready;

  // signals for module outputs
  wire [63 : 0] axi4_m_araddr, axi4_m_awaddr, axi4_m_wdata;
  wire [15 : 0] axi4_m_arid, axi4_m_awid;
  wire [7 : 0] axi4_m_arlen, axi4_m_awlen, axi4_m_wstrb;
  wire [5 : 0] axi4_m_awatop;
  wire [3 : 0] axi4_m_arcache,
	       axi4_m_arqos,
	       axi4_m_arregion,
	       axi4_m_awcache,
	       axi4_m_awqos,
	       axi4_m_awregion;
  wire [2 : 0] axi4_m_arprot, axi4_m_arsize, axi4_m_awprot, axi4_m_awsize;
  wire [1 : 0] axi4_m_arburst, axi4_m_awburst;
  wire axi4_m_arlock,
       axi4_m_arvalid,
       axi4_m_awlock,
       axi4_m_awvalid,
       axi4_m_bready,
       axi4_m_rready,
       axi4_m_wlast,
       axi4_m_wvalid;

  /*
  // rule scheduling signals
  wire CAN_FIRE_axi4_m_m_arready,
       CAN_FIRE_axi4_m_m_awready,
       CAN_FIRE_axi4_m_m_bvalid,
       CAN_FIRE_axi4_m_m_rvalid,
       CAN_FIRE_axi4_m_m_wready,
       CAN_FIRE_m_boot_addr,
       CAN_FIRE_m_hart_id,
       CAN_FIRE_m_irq_external,
       CAN_FIRE_m_irq_software,
       CAN_FIRE_m_irq_timer,
       WILL_FIRE_axi4_m_m_arready,
       WILL_FIRE_axi4_m_m_awready,
       WILL_FIRE_axi4_m_m_bvalid,
       WILL_FIRE_axi4_m_m_rvalid,
       WILL_FIRE_axi4_m_m_wready,
       WILL_FIRE_m_boot_addr,
       WILL_FIRE_m_hart_id,
       WILL_FIRE_m_irq_external,
       WILL_FIRE_m_irq_software,
       WILL_FIRE_m_irq_timer;

  // action method m_boot_addr
  assign CAN_FIRE_m_boot_addr = 1'd1 ;
  assign WILL_FIRE_m_boot_addr = 1'd1 ;

  // action method m_hart_id
  assign CAN_FIRE_m_hart_id = 1'd1 ;
  assign WILL_FIRE_m_hart_id = 1'd1 ;

  // action method m_irq_external
  assign CAN_FIRE_m_irq_external = 1'd1 ;
  assign WILL_FIRE_m_irq_external = 1'd1 ;

  // action method m_irq_software
  assign CAN_FIRE_m_irq_software = 1'd1 ;
  assign WILL_FIRE_m_irq_software = 1'd1 ;

  // action method m_irq_timer
  assign CAN_FIRE_m_irq_timer = 1'd1 ;
  assign WILL_FIRE_m_irq_timer = 1'd1 ;

  // value method axi4_m_awatop
  assign axi4_m_awatop = 6'h0 ;

  // value method axi4_m_m_awvalid
  assign axi4_m_awvalid = 1'd0 ;

  // value method axi4_m_m_awid
  assign axi4_m_awid = 16'hAAAA ;

  // value method axi4_m_m_awaddr
  assign axi4_m_awaddr = 64'hAAAAAAAAAAAAAAAA ;

  // value method axi4_m_m_awlen
  assign axi4_m_awlen = 8'hAA ;

  // value method axi4_m_m_awsize
  assign axi4_m_awsize = 3'h2 ;

  // value method axi4_m_m_awburst
  assign axi4_m_awburst = 2'h2 ;

  // value method axi4_m_m_awlock
  assign axi4_m_awlock = 1'h0 ;

  // value method axi4_m_m_awcache
  assign axi4_m_awcache = 4'hA ;

  // value method axi4_m_m_awprot
  assign axi4_m_awprot = 3'h2 ;

  // value method axi4_m_m_awqos
  assign axi4_m_awqos = 4'hA ;

  // value method axi4_m_m_awregion
  assign axi4_m_awregion = 4'hA ;

  // action method axi4_m_m_awready
  assign CAN_FIRE_axi4_m_m_awready = 1'd1 ;
  assign WILL_FIRE_axi4_m_m_awready = 1'd1 ;

  // value method axi4_m_m_wvalid
  assign axi4_m_wvalid = 1'd0 ;

  // value method axi4_m_m_wdata
  assign axi4_m_wdata = 64'hAAAAAAAAAAAAAAAA ;

  // value method axi4_m_m_wstrb
  assign axi4_m_wstrb = 8'hAA ;

  // value method axi4_m_m_wlast
  assign axi4_m_wlast = 1'h0 ;

  // action method axi4_m_m_wready
  assign CAN_FIRE_axi4_m_m_wready = 1'd1 ;
  assign WILL_FIRE_axi4_m_m_wready = 1'd1 ;

  // action method axi4_m_m_bvalid
  assign CAN_FIRE_axi4_m_m_bvalid = 1'd1 ;
  assign WILL_FIRE_axi4_m_m_bvalid = 1'd1 ;

  // value method axi4_m_m_bready
  assign axi4_m_bready = 1'd0 ;

  // value method axi4_m_m_arvalid
  assign axi4_m_arvalid = 1'd0 ;

  // value method axi4_m_m_arid
  assign axi4_m_arid = 16'hAAAA ;

  // value method axi4_m_m_araddr
  assign axi4_m_araddr = 64'hAAAAAAAAAAAAAAAA ;

  // value method axi4_m_m_arlen
  assign axi4_m_arlen = 8'hAA ;

  // value method axi4_m_m_arsize
  assign axi4_m_arsize = 3'h2 ;

  // value method axi4_m_m_arburst
  assign axi4_m_arburst = 2'h2 ;

  // value method axi4_m_m_arlock
  assign axi4_m_arlock = 1'h0 ;

  // value method axi4_m_m_arcache
  assign axi4_m_arcache = 4'hA ;

  // value method axi4_m_m_arprot
  assign axi4_m_arprot = 3'h2 ;

  // value method axi4_m_m_arqos
  assign axi4_m_arqos = 4'hA ;

  // value method axi4_m_m_arregion
  assign axi4_m_arregion = 4'hA ;

  // action method axi4_m_m_arready
  assign CAN_FIRE_axi4_m_m_arready = 1'd1 ;
  assign WILL_FIRE_axi4_m_m_arready = 1'd1 ;

  // action method axi4_m_m_rvalid
  assign CAN_FIRE_axi4_m_m_rvalid = 1'd1 ;
  assign WILL_FIRE_axi4_m_m_rvalid = 1'd1 ;

  // value method axi4_m_m_rready
  assign axi4_m_rready = 1'd0 ;
  */

// Copyright (c) 2023 Bluespec, Inc. All Rights Reserved.

// ================================================================
// CAUTION: this is an 'include' file, to  be included into a SystemVerilog module.
// This is the hand-written body for module mkCVA6_Shim.
// It instantiates module 'cva6' (ariane) and connects ports
// ================================================================

// See definitions of structs
//     req_t, resp_t
//     aw_chan_t, w_chan_t, b_chan_t, ar_chan_t, r_chan_t
// in package 'ariane_axi_soc'
// in file 'cva6/corev_apu/tb/ariane_axi_soc_pkg.sv'

ariane_axi_soc::req_t    axi_req;

//  aw_chan_t aw;
//    id_t              id;
//    addr_t            addr;
//    axi_pkg::len_t    len;
//    axi_pkg::size_t   size;
//    axi_pkg::burst_t  burst;
//    logic             lock;
//    axi_pkg::cache_t  cache;
//    axi_pkg::prot_t   prot;
//    axi_pkg::qos_t    qos;
//    axi_pkg::region_t region;
//    axi_pkg::atop_t   atop;
//    user_t            user;
assign axi4_m_awid     = axi_req.aw.id;
assign axi4_m_awaddr   = axi_req.aw.addr;
assign axi4_m_awlen    = axi_req.aw.len;
assign axi4_m_awsize   = axi_req.aw.size;
assign axi4_m_awburst  = axi_req.aw.burst;
assign axi4_m_awlock   = axi_req.aw.lock;
assign axi4_m_awcache  = axi_req.aw.cache;
assign axi4_m_awprot   = axi_req.aw.prot;
assign axi4_m_awqos    = axi_req.aw.qos;
assign axi4_m_awregion = axi_req.aw.region;
assign axi4_m_awatop   = axi_req.aw.atop;     // Atomic Op
// assign axi4_m_awuser = axi_req.aw.user;    // axi_req.aw.user is a bogus 1b signal

//  logic     aw_valid;
assign axi4_m_awvalid = axi_req.aw_valid;

//  w_chan_t  w;
//    data_t data;
//    strb_t strb;
//    logic  last;
//    user_t user;
assign axi4_m_wdata = axi_req.w.data;
assign axi4_m_wstrb = axi_req.w.strb;
assign axi4_m_wlast = axi_req.w.last;
// assign axi4_m_wuser = axi_req.w.user;    // axi_req.w.user is a bogus 1b signal

//  logic     w_valid;
assign axi4_m_wvalid = axi_req.w_valid;

//  logic     b_ready;
assign axi4_m_bready = axi_req.b_ready;

//  ar_chan_t ar;
assign axi4_m_arid     = axi_req.ar.id;
assign axi4_m_araddr   = axi_req.ar.addr;
assign axi4_m_arlen    = axi_req.ar.len;
assign axi4_m_arsize   = axi_req.ar.size;
assign axi4_m_arburst  = axi_req.ar.burst;
assign axi4_m_arlock   = axi_req.ar.lock;
assign axi4_m_arcache  = axi_req.ar.cache;
assign axi4_m_arprot   = axi_req.ar.prot;
assign axi4_m_arqos    = axi_req.ar.qos;
assign axi4_m_arregion = axi_req.ar.region;
// assign axi4_m_aruser   = axi_req.ar.user;    // req.ar.user is a bogus 1b signal

//  logic     ar_valid;
assign axi4_m_arvalid = axi_req.ar_valid;

//  logic     r_ready;
assign axi4_m_rready = axi_req.r_ready;

// ----------------------------------------------------------------
// AXI4 inputs

ariane_axi_soc::resp_t   axi_resp;

//  logic     aw_ready;
assign axi_resp.aw_ready = axi4_m_awready;

//  logic     ar_ready;
assign axi_resp.ar_ready = axi4_m_arready;

//  logic     w_ready;
assign axi_resp.w_ready = axi4_m_wready;

//  logic     b_valid;
assign axi_resp.b_valid = axi4_m_bvalid;

//  b_chan_t  b;
//    id_t            id;
//    axi_pkg::resp_t resp;
//    user_t          user;
assign axi_resp.b.id   = axi4_m_bid;
assign axi_resp.b.resp = axi4_m_bresp;
assign axi_resp.b.user = 0;               // axi_resp.b.user is a bogus 1b signal

//  logic     r_valid;
assign axi_resp.r_valid = axi4_m_rvalid;

//  r_chan_t  r;
//    id_t            id;
//    data_t          data;
//    axi_pkg::resp_t resp;
//    logic           last;
//    user_t          user;
assign axi_resp.r.id   = axi4_m_rid;
assign axi_resp.r.data = axi4_m_rdata;
assign axi_resp.r.resp = axi4_m_rresp;
assign axi_resp.r.last = axi4_m_rlast;
assign axi_resp.r.user = 0;               // axi_resp.r.user is a bogus 1b signal

// ----------------------------------------------------------------
// CVXIF (OpenHardware Group Extension Interface)

cvxif_pkg::cvxif_req_t        cvxif_req;
cvxif_pkg::cvxif_resp_t       cvxif_resp;

assign cvxif_resp = 0;

// ----------------------------------------------------------------
// Instantiate the 'cva6' module

cva6 #()
i_cva6 (.clk_i                ( CLK         ),
	.rst_ni               ( RST_N       ),
	.boot_addr_i          ( boot_addr_i ),
	.hart_id_i            ( hart_id_i   ),
	.irq_i                ( irq_i       ),
	.ipi_i                ( ipi_i       ),
	.time_irq_i           ( time_irq_i  ),
	.debug_req_i          ( 1'b0        ),
	.cvxif_req_o          ( cvxif_req   ),
	.cvxif_resp_i         ( cvxif_resp  ),
	.axi_req_o            ( axi_req     ),
	.axi_resp_i           ( axi_resp    )
	);

// ================================================================

endmodule  // mkCVA6_Shim
