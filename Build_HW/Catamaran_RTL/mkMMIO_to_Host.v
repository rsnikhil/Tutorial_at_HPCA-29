//
// Generated by Bluespec Compiler, version 2023.01 (build 52adafa5)
//
//
// Ports:
// Name                         I/O  size props
// axi4_S_awready                 O     1 reg
// axi4_S_wready                  O     1 reg
// axi4_S_bvalid                  O     1 reg
// axi4_S_bid                     O    16 reg
// axi4_S_bresp                   O     2 reg
// axi4_S_arready                 O     1 reg
// axi4_S_rvalid                  O     1 reg
// axi4_S_rid                     O    16 reg
// axi4_S_rdata                   O    64 reg
// axi4_S_rresp                   O     2 reg
// axi4_S_rlast                   O     1 reg
// to_host_get                    O    32 reg
// RDY_to_host_get                O     1 reg
// RDY_from_host_put              O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// axi4_S_awvalid                 I     1
// axi4_S_awid                    I    16 reg
// axi4_S_awaddr                  I    64 reg
// axi4_S_awlen                   I     8 reg
// axi4_S_awsize                  I     3 reg
// axi4_S_awburst                 I     2 reg
// axi4_S_awlock                  I     1 reg
// axi4_S_awcache                 I     4 reg
// axi4_S_awprot                  I     3 reg
// axi4_S_awqos                   I     4 reg
// axi4_S_awregion                I     4 reg
// axi4_S_wvalid                  I     1
// axi4_S_wdata                   I    64 reg
// axi4_S_wstrb                   I     8 reg
// axi4_S_wlast                   I     1 reg
// axi4_S_bready                  I     1
// axi4_S_arvalid                 I     1
// axi4_S_arid                    I    16 reg
// axi4_S_araddr                  I    64 reg
// axi4_S_arlen                   I     8 reg
// axi4_S_arsize                  I     3 reg
// axi4_S_arburst                 I     2 reg
// axi4_S_arlock                  I     1 reg
// axi4_S_arcache                 I     4 reg
// axi4_S_arprot                  I     3 reg
// axi4_S_arqos                   I     4 reg
// axi4_S_arregion                I     4 reg
// axi4_S_rready                  I     1
// from_host_put                  I    32 reg
// EN_from_host_put               I     1
// EN_to_host_get                 I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkMMIO_to_Host(CLK,
		      RST_N,

		      axi4_S_awvalid,
		      axi4_S_awid,
		      axi4_S_awaddr,
		      axi4_S_awlen,
		      axi4_S_awsize,
		      axi4_S_awburst,
		      axi4_S_awlock,
		      axi4_S_awcache,
		      axi4_S_awprot,
		      axi4_S_awqos,
		      axi4_S_awregion,

		      axi4_S_awready,

		      axi4_S_wvalid,
		      axi4_S_wdata,
		      axi4_S_wstrb,
		      axi4_S_wlast,

		      axi4_S_wready,

		      axi4_S_bvalid,

		      axi4_S_bid,

		      axi4_S_bresp,

		      axi4_S_bready,

		      axi4_S_arvalid,
		      axi4_S_arid,
		      axi4_S_araddr,
		      axi4_S_arlen,
		      axi4_S_arsize,
		      axi4_S_arburst,
		      axi4_S_arlock,
		      axi4_S_arcache,
		      axi4_S_arprot,
		      axi4_S_arqos,
		      axi4_S_arregion,

		      axi4_S_arready,

		      axi4_S_rvalid,

		      axi4_S_rid,

		      axi4_S_rdata,

		      axi4_S_rresp,

		      axi4_S_rlast,

		      axi4_S_rready,

		      EN_to_host_get,
		      to_host_get,
		      RDY_to_host_get,

		      from_host_put,
		      EN_from_host_put,
		      RDY_from_host_put);
  input  CLK;
  input  RST_N;

  // action method axi4_S_m_awvalid
  input  axi4_S_awvalid;
  input  [15 : 0] axi4_S_awid;
  input  [63 : 0] axi4_S_awaddr;
  input  [7 : 0] axi4_S_awlen;
  input  [2 : 0] axi4_S_awsize;
  input  [1 : 0] axi4_S_awburst;
  input  axi4_S_awlock;
  input  [3 : 0] axi4_S_awcache;
  input  [2 : 0] axi4_S_awprot;
  input  [3 : 0] axi4_S_awqos;
  input  [3 : 0] axi4_S_awregion;

  // value method axi4_S_m_awready
  output axi4_S_awready;

  // action method axi4_S_m_wvalid
  input  axi4_S_wvalid;
  input  [63 : 0] axi4_S_wdata;
  input  [7 : 0] axi4_S_wstrb;
  input  axi4_S_wlast;

  // value method axi4_S_m_wready
  output axi4_S_wready;

  // value method axi4_S_m_bvalid
  output axi4_S_bvalid;

  // value method axi4_S_m_bid
  output [15 : 0] axi4_S_bid;

  // value method axi4_S_m_bresp
  output [1 : 0] axi4_S_bresp;

  // value method axi4_S_m_buser

  // action method axi4_S_m_bready
  input  axi4_S_bready;

  // action method axi4_S_m_arvalid
  input  axi4_S_arvalid;
  input  [15 : 0] axi4_S_arid;
  input  [63 : 0] axi4_S_araddr;
  input  [7 : 0] axi4_S_arlen;
  input  [2 : 0] axi4_S_arsize;
  input  [1 : 0] axi4_S_arburst;
  input  axi4_S_arlock;
  input  [3 : 0] axi4_S_arcache;
  input  [2 : 0] axi4_S_arprot;
  input  [3 : 0] axi4_S_arqos;
  input  [3 : 0] axi4_S_arregion;

  // value method axi4_S_m_arready
  output axi4_S_arready;

  // value method axi4_S_m_rvalid
  output axi4_S_rvalid;

  // value method axi4_S_m_rid
  output [15 : 0] axi4_S_rid;

  // value method axi4_S_m_rdata
  output [63 : 0] axi4_S_rdata;

  // value method axi4_S_m_rresp
  output [1 : 0] axi4_S_rresp;

  // value method axi4_S_m_rlast
  output axi4_S_rlast;

  // value method axi4_S_m_ruser

  // action method axi4_S_m_rready
  input  axi4_S_rready;

  // actionvalue method to_host_get
  input  EN_to_host_get;
  output [31 : 0] to_host_get;
  output RDY_to_host_get;

  // action method from_host_put
  input  [31 : 0] from_host_put;
  input  EN_from_host_put;
  output RDY_from_host_put;

  // signals for module outputs
  wire [63 : 0] axi4_S_rdata;
  wire [31 : 0] to_host_get;
  wire [15 : 0] axi4_S_bid, axi4_S_rid;
  wire [1 : 0] axi4_S_bresp, axi4_S_rresp;
  wire RDY_from_host_put,
       RDY_to_host_get,
       axi4_S_arready,
       axi4_S_awready,
       axi4_S_bvalid,
       axi4_S_rlast,
       axi4_S_rvalid,
       axi4_S_wready;

  // register rg_wdata_pending
  reg [32 : 0] rg_wdata_pending;
  wire [32 : 0] rg_wdata_pending$D_IN;
  wire rg_wdata_pending$EN;

  // ports of submodule axi4_S_xactor_f_rd_addr
  wire [108 : 0] axi4_S_xactor_f_rd_addr$D_IN, axi4_S_xactor_f_rd_addr$D_OUT;
  wire axi4_S_xactor_f_rd_addr$CLR,
       axi4_S_xactor_f_rd_addr$DEQ,
       axi4_S_xactor_f_rd_addr$EMPTY_N,
       axi4_S_xactor_f_rd_addr$ENQ,
       axi4_S_xactor_f_rd_addr$FULL_N;

  // ports of submodule axi4_S_xactor_f_rd_data
  wire [82 : 0] axi4_S_xactor_f_rd_data$D_IN, axi4_S_xactor_f_rd_data$D_OUT;
  wire axi4_S_xactor_f_rd_data$CLR,
       axi4_S_xactor_f_rd_data$DEQ,
       axi4_S_xactor_f_rd_data$EMPTY_N,
       axi4_S_xactor_f_rd_data$ENQ,
       axi4_S_xactor_f_rd_data$FULL_N;

  // ports of submodule axi4_S_xactor_f_wr_addr
  wire [108 : 0] axi4_S_xactor_f_wr_addr$D_IN, axi4_S_xactor_f_wr_addr$D_OUT;
  wire axi4_S_xactor_f_wr_addr$CLR,
       axi4_S_xactor_f_wr_addr$DEQ,
       axi4_S_xactor_f_wr_addr$EMPTY_N,
       axi4_S_xactor_f_wr_addr$ENQ,
       axi4_S_xactor_f_wr_addr$FULL_N;

  // ports of submodule axi4_S_xactor_f_wr_data
  wire [72 : 0] axi4_S_xactor_f_wr_data$D_IN, axi4_S_xactor_f_wr_data$D_OUT;
  wire axi4_S_xactor_f_wr_data$CLR,
       axi4_S_xactor_f_wr_data$DEQ,
       axi4_S_xactor_f_wr_data$EMPTY_N,
       axi4_S_xactor_f_wr_data$ENQ,
       axi4_S_xactor_f_wr_data$FULL_N;

  // ports of submodule axi4_S_xactor_f_wr_resp
  wire [17 : 0] axi4_S_xactor_f_wr_resp$D_IN, axi4_S_xactor_f_wr_resp$D_OUT;
  wire axi4_S_xactor_f_wr_resp$CLR,
       axi4_S_xactor_f_wr_resp$DEQ,
       axi4_S_xactor_f_wr_resp$EMPTY_N,
       axi4_S_xactor_f_wr_resp$ENQ,
       axi4_S_xactor_f_wr_resp$FULL_N;

  // ports of submodule f_from_host
  wire [31 : 0] f_from_host$D_IN, f_from_host$D_OUT;
  wire f_from_host$CLR,
       f_from_host$DEQ,
       f_from_host$EMPTY_N,
       f_from_host$ENQ,
       f_from_host$FULL_N;

  // ports of submodule f_rsps_pending
  wire [48 : 0] f_rsps_pending$D_IN, f_rsps_pending$D_OUT;
  wire f_rsps_pending$CLR,
       f_rsps_pending$DEQ,
       f_rsps_pending$EMPTY_N,
       f_rsps_pending$ENQ,
       f_rsps_pending$FULL_N;

  // ports of submodule f_to_host
  reg [31 : 0] f_to_host$D_IN;
  wire [31 : 0] f_to_host$D_OUT;
  wire f_to_host$CLR,
       f_to_host$DEQ,
       f_to_host$EMPTY_N,
       f_to_host$ENQ,
       f_to_host$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_rl_forward_rd_req_addr,
       CAN_FIRE_RL_rl_forward_rd_rsp,
       CAN_FIRE_RL_rl_forward_wr_req_addr,
       CAN_FIRE_RL_rl_forward_wr_req_data,
       CAN_FIRE_axi4_S_m_arvalid,
       CAN_FIRE_axi4_S_m_awvalid,
       CAN_FIRE_axi4_S_m_bready,
       CAN_FIRE_axi4_S_m_rready,
       CAN_FIRE_axi4_S_m_wvalid,
       CAN_FIRE_from_host_put,
       CAN_FIRE_to_host_get,
       WILL_FIRE_RL_rl_forward_rd_req_addr,
       WILL_FIRE_RL_rl_forward_rd_rsp,
       WILL_FIRE_RL_rl_forward_wr_req_addr,
       WILL_FIRE_RL_rl_forward_wr_req_data,
       WILL_FIRE_axi4_S_m_arvalid,
       WILL_FIRE_axi4_S_m_awvalid,
       WILL_FIRE_axi4_S_m_bready,
       WILL_FIRE_axi4_S_m_rready,
       WILL_FIRE_axi4_S_m_wvalid,
       WILL_FIRE_from_host_put,
       WILL_FIRE_to_host_get;

  // inputs to muxes for submodule ports
  wire [32 : 0] MUX_rg_wdata_pending$write_1__VAL_2;
  wire [31 : 0] MUX_f_to_host$enq_1__VAL_1,
		MUX_f_to_host$enq_1__VAL_2,
		MUX_f_to_host$enq_1__VAL_3;

  // remaining internal signals
  wire [63 : 0] _theResult____h1716;
  wire [31 : 0] rg_wdata_pending_BITS_31_TO_0__q1;

  // action method axi4_S_m_awvalid
  assign CAN_FIRE_axi4_S_m_awvalid = 1'd1 ;
  assign WILL_FIRE_axi4_S_m_awvalid = 1'd1 ;

  // value method axi4_S_m_awready
  assign axi4_S_awready = axi4_S_xactor_f_wr_addr$FULL_N ;

  // action method axi4_S_m_wvalid
  assign CAN_FIRE_axi4_S_m_wvalid = 1'd1 ;
  assign WILL_FIRE_axi4_S_m_wvalid = 1'd1 ;

  // value method axi4_S_m_wready
  assign axi4_S_wready = axi4_S_xactor_f_wr_data$FULL_N ;

  // value method axi4_S_m_bvalid
  assign axi4_S_bvalid = axi4_S_xactor_f_wr_resp$EMPTY_N ;

  // value method axi4_S_m_bid
  assign axi4_S_bid = axi4_S_xactor_f_wr_resp$D_OUT[17:2] ;

  // value method axi4_S_m_bresp
  assign axi4_S_bresp = axi4_S_xactor_f_wr_resp$D_OUT[1:0] ;

  // action method axi4_S_m_bready
  assign CAN_FIRE_axi4_S_m_bready = 1'd1 ;
  assign WILL_FIRE_axi4_S_m_bready = 1'd1 ;

  // action method axi4_S_m_arvalid
  assign CAN_FIRE_axi4_S_m_arvalid = 1'd1 ;
  assign WILL_FIRE_axi4_S_m_arvalid = 1'd1 ;

  // value method axi4_S_m_arready
  assign axi4_S_arready = axi4_S_xactor_f_rd_addr$FULL_N ;

  // value method axi4_S_m_rvalid
  assign axi4_S_rvalid = axi4_S_xactor_f_rd_data$EMPTY_N ;

  // value method axi4_S_m_rid
  assign axi4_S_rid = axi4_S_xactor_f_rd_data$D_OUT[82:67] ;

  // value method axi4_S_m_rdata
  assign axi4_S_rdata = axi4_S_xactor_f_rd_data$D_OUT[66:3] ;

  // value method axi4_S_m_rresp
  assign axi4_S_rresp = axi4_S_xactor_f_rd_data$D_OUT[2:1] ;

  // value method axi4_S_m_rlast
  assign axi4_S_rlast = axi4_S_xactor_f_rd_data$D_OUT[0] ;

  // action method axi4_S_m_rready
  assign CAN_FIRE_axi4_S_m_rready = 1'd1 ;
  assign WILL_FIRE_axi4_S_m_rready = 1'd1 ;

  // actionvalue method to_host_get
  assign to_host_get = f_to_host$D_OUT ;
  assign RDY_to_host_get = f_to_host$EMPTY_N ;
  assign CAN_FIRE_to_host_get = f_to_host$EMPTY_N ;
  assign WILL_FIRE_to_host_get = EN_to_host_get ;

  // action method from_host_put
  assign RDY_from_host_put = f_from_host$FULL_N ;
  assign CAN_FIRE_from_host_put = f_from_host$FULL_N ;
  assign WILL_FIRE_from_host_put = EN_from_host_put ;

  // submodule axi4_S_xactor_f_rd_addr
  FIFO2 #(.width(32'd109),
	  .guarded(1'd1)) axi4_S_xactor_f_rd_addr(.RST(RST_N),
						  .CLK(CLK),
						  .D_IN(axi4_S_xactor_f_rd_addr$D_IN),
						  .ENQ(axi4_S_xactor_f_rd_addr$ENQ),
						  .DEQ(axi4_S_xactor_f_rd_addr$DEQ),
						  .CLR(axi4_S_xactor_f_rd_addr$CLR),
						  .D_OUT(axi4_S_xactor_f_rd_addr$D_OUT),
						  .FULL_N(axi4_S_xactor_f_rd_addr$FULL_N),
						  .EMPTY_N(axi4_S_xactor_f_rd_addr$EMPTY_N));

  // submodule axi4_S_xactor_f_rd_data
  FIFO2 #(.width(32'd83), .guarded(1'd1)) axi4_S_xactor_f_rd_data(.RST(RST_N),
								  .CLK(CLK),
								  .D_IN(axi4_S_xactor_f_rd_data$D_IN),
								  .ENQ(axi4_S_xactor_f_rd_data$ENQ),
								  .DEQ(axi4_S_xactor_f_rd_data$DEQ),
								  .CLR(axi4_S_xactor_f_rd_data$CLR),
								  .D_OUT(axi4_S_xactor_f_rd_data$D_OUT),
								  .FULL_N(axi4_S_xactor_f_rd_data$FULL_N),
								  .EMPTY_N(axi4_S_xactor_f_rd_data$EMPTY_N));

  // submodule axi4_S_xactor_f_wr_addr
  FIFO2 #(.width(32'd109),
	  .guarded(1'd1)) axi4_S_xactor_f_wr_addr(.RST(RST_N),
						  .CLK(CLK),
						  .D_IN(axi4_S_xactor_f_wr_addr$D_IN),
						  .ENQ(axi4_S_xactor_f_wr_addr$ENQ),
						  .DEQ(axi4_S_xactor_f_wr_addr$DEQ),
						  .CLR(axi4_S_xactor_f_wr_addr$CLR),
						  .D_OUT(axi4_S_xactor_f_wr_addr$D_OUT),
						  .FULL_N(axi4_S_xactor_f_wr_addr$FULL_N),
						  .EMPTY_N(axi4_S_xactor_f_wr_addr$EMPTY_N));

  // submodule axi4_S_xactor_f_wr_data
  FIFO2 #(.width(32'd73), .guarded(1'd1)) axi4_S_xactor_f_wr_data(.RST(RST_N),
								  .CLK(CLK),
								  .D_IN(axi4_S_xactor_f_wr_data$D_IN),
								  .ENQ(axi4_S_xactor_f_wr_data$ENQ),
								  .DEQ(axi4_S_xactor_f_wr_data$DEQ),
								  .CLR(axi4_S_xactor_f_wr_data$CLR),
								  .D_OUT(axi4_S_xactor_f_wr_data$D_OUT),
								  .FULL_N(axi4_S_xactor_f_wr_data$FULL_N),
								  .EMPTY_N(axi4_S_xactor_f_wr_data$EMPTY_N));

  // submodule axi4_S_xactor_f_wr_resp
  FIFO2 #(.width(32'd18), .guarded(1'd1)) axi4_S_xactor_f_wr_resp(.RST(RST_N),
								  .CLK(CLK),
								  .D_IN(axi4_S_xactor_f_wr_resp$D_IN),
								  .ENQ(axi4_S_xactor_f_wr_resp$ENQ),
								  .DEQ(axi4_S_xactor_f_wr_resp$DEQ),
								  .CLR(axi4_S_xactor_f_wr_resp$CLR),
								  .D_OUT(axi4_S_xactor_f_wr_resp$D_OUT),
								  .FULL_N(axi4_S_xactor_f_wr_resp$FULL_N),
								  .EMPTY_N(axi4_S_xactor_f_wr_resp$EMPTY_N));

  // submodule f_from_host
  FIFO2 #(.width(32'd32), .guarded(1'd1)) f_from_host(.RST(RST_N),
						      .CLK(CLK),
						      .D_IN(f_from_host$D_IN),
						      .ENQ(f_from_host$ENQ),
						      .DEQ(f_from_host$DEQ),
						      .CLR(f_from_host$CLR),
						      .D_OUT(f_from_host$D_OUT),
						      .FULL_N(f_from_host$FULL_N),
						      .EMPTY_N(f_from_host$EMPTY_N));

  // submodule f_rsps_pending
  SizedFIFO #(.p1width(32'd49),
	      .p2depth(32'd32),
	      .p3cntr_width(32'd5),
	      .guarded(1'd1)) f_rsps_pending(.RST(RST_N),
					     .CLK(CLK),
					     .D_IN(f_rsps_pending$D_IN),
					     .ENQ(f_rsps_pending$ENQ),
					     .DEQ(f_rsps_pending$DEQ),
					     .CLR(f_rsps_pending$CLR),
					     .D_OUT(f_rsps_pending$D_OUT),
					     .FULL_N(f_rsps_pending$FULL_N),
					     .EMPTY_N(f_rsps_pending$EMPTY_N));

  // submodule f_to_host
  FIFO2 #(.width(32'd32), .guarded(1'd1)) f_to_host(.RST(RST_N),
						    .CLK(CLK),
						    .D_IN(f_to_host$D_IN),
						    .ENQ(f_to_host$ENQ),
						    .DEQ(f_to_host$DEQ),
						    .CLR(f_to_host$CLR),
						    .D_OUT(f_to_host$D_OUT),
						    .FULL_N(f_to_host$FULL_N),
						    .EMPTY_N(f_to_host$EMPTY_N));

  // rule RL_rl_forward_rd_req_addr
  assign CAN_FIRE_RL_rl_forward_rd_req_addr =
	     axi4_S_xactor_f_rd_addr$EMPTY_N && f_to_host$FULL_N &&
	     f_rsps_pending$FULL_N &&
	     !rg_wdata_pending[32] ;
  assign WILL_FIRE_RL_rl_forward_rd_req_addr =
	     CAN_FIRE_RL_rl_forward_rd_req_addr ;

  // rule RL_rl_forward_wr_req_addr
  assign CAN_FIRE_RL_rl_forward_wr_req_addr =
	     f_to_host$FULL_N && axi4_S_xactor_f_wr_addr$EMPTY_N &&
	     axi4_S_xactor_f_wr_resp$FULL_N &&
	     !rg_wdata_pending[32] ;
  assign WILL_FIRE_RL_rl_forward_wr_req_addr =
	     CAN_FIRE_RL_rl_forward_wr_req_addr &&
	     !WILL_FIRE_RL_rl_forward_rd_req_addr ;

  // rule RL_rl_forward_wr_req_data
  assign CAN_FIRE_RL_rl_forward_wr_req_data =
	     f_to_host$FULL_N && axi4_S_xactor_f_wr_data$EMPTY_N &&
	     rg_wdata_pending[32] ;
  assign WILL_FIRE_RL_rl_forward_wr_req_data =
	     CAN_FIRE_RL_rl_forward_wr_req_data ;

  // rule RL_rl_forward_rd_rsp
  assign CAN_FIRE_RL_rl_forward_rd_rsp =
	     f_rsps_pending$EMPTY_N && f_from_host$EMPTY_N &&
	     axi4_S_xactor_f_rd_data$FULL_N &&
	     !f_rsps_pending$D_OUT[48] ;
  assign WILL_FIRE_RL_rl_forward_rd_rsp = CAN_FIRE_RL_rl_forward_rd_rsp ;

  // inputs to muxes for submodule ports
  assign MUX_f_to_host$enq_1__VAL_1 =
	     { axi4_S_xactor_f_rd_addr$D_OUT[60:31], 2'd0 } ;
  assign MUX_f_to_host$enq_1__VAL_2 =
	     { axi4_S_xactor_f_wr_addr$D_OUT[60:31], 2'd1 } ;
  assign MUX_f_to_host$enq_1__VAL_3 =
	     (rg_wdata_pending_BITS_31_TO_0__q1[2:0] == 3'b100) ?
	       axi4_S_xactor_f_wr_data$D_OUT[72:41] :
	       axi4_S_xactor_f_wr_data$D_OUT[40:9] ;
  assign MUX_rg_wdata_pending$write_1__VAL_2 =
	     { 1'd1, axi4_S_xactor_f_wr_addr$D_OUT[60:29] } ;

  // register rg_wdata_pending
  assign rg_wdata_pending$D_IN =
	     WILL_FIRE_RL_rl_forward_wr_req_data ?
	       33'h0AAAAAAAA :
	       MUX_rg_wdata_pending$write_1__VAL_2 ;
  assign rg_wdata_pending$EN =
	     WILL_FIRE_RL_rl_forward_wr_req_data ||
	     WILL_FIRE_RL_rl_forward_wr_req_addr ;

  // submodule axi4_S_xactor_f_rd_addr
  assign axi4_S_xactor_f_rd_addr$D_IN =
	     { axi4_S_arid,
	       axi4_S_araddr,
	       axi4_S_arlen,
	       axi4_S_arsize,
	       axi4_S_arburst,
	       axi4_S_arlock,
	       axi4_S_arcache,
	       axi4_S_arprot,
	       axi4_S_arqos,
	       axi4_S_arregion } ;
  assign axi4_S_xactor_f_rd_addr$ENQ =
	     axi4_S_arvalid && axi4_S_xactor_f_rd_addr$FULL_N ;
  assign axi4_S_xactor_f_rd_addr$DEQ = CAN_FIRE_RL_rl_forward_rd_req_addr ;
  assign axi4_S_xactor_f_rd_addr$CLR = 1'b0 ;

  // submodule axi4_S_xactor_f_rd_data
  assign axi4_S_xactor_f_rd_data$D_IN =
	     { f_rsps_pending$D_OUT[15:0], _theResult____h1716, 3'd1 } ;
  assign axi4_S_xactor_f_rd_data$ENQ = CAN_FIRE_RL_rl_forward_rd_rsp ;
  assign axi4_S_xactor_f_rd_data$DEQ =
	     axi4_S_rready && axi4_S_xactor_f_rd_data$EMPTY_N ;
  assign axi4_S_xactor_f_rd_data$CLR = 1'b0 ;

  // submodule axi4_S_xactor_f_wr_addr
  assign axi4_S_xactor_f_wr_addr$D_IN =
	     { axi4_S_awid,
	       axi4_S_awaddr,
	       axi4_S_awlen,
	       axi4_S_awsize,
	       axi4_S_awburst,
	       axi4_S_awlock,
	       axi4_S_awcache,
	       axi4_S_awprot,
	       axi4_S_awqos,
	       axi4_S_awregion } ;
  assign axi4_S_xactor_f_wr_addr$ENQ =
	     axi4_S_awvalid && axi4_S_xactor_f_wr_addr$FULL_N ;
  assign axi4_S_xactor_f_wr_addr$DEQ = WILL_FIRE_RL_rl_forward_wr_req_addr ;
  assign axi4_S_xactor_f_wr_addr$CLR = 1'b0 ;

  // submodule axi4_S_xactor_f_wr_data
  assign axi4_S_xactor_f_wr_data$D_IN =
	     { axi4_S_wdata, axi4_S_wstrb, axi4_S_wlast } ;
  assign axi4_S_xactor_f_wr_data$ENQ =
	     axi4_S_wvalid && axi4_S_xactor_f_wr_data$FULL_N ;
  assign axi4_S_xactor_f_wr_data$DEQ = CAN_FIRE_RL_rl_forward_wr_req_data ;
  assign axi4_S_xactor_f_wr_data$CLR = 1'b0 ;

  // submodule axi4_S_xactor_f_wr_resp
  assign axi4_S_xactor_f_wr_resp$D_IN =
	     { axi4_S_xactor_f_wr_addr$D_OUT[108:93], 2'd0 } ;
  assign axi4_S_xactor_f_wr_resp$ENQ = WILL_FIRE_RL_rl_forward_wr_req_addr ;
  assign axi4_S_xactor_f_wr_resp$DEQ =
	     axi4_S_bready && axi4_S_xactor_f_wr_resp$EMPTY_N ;
  assign axi4_S_xactor_f_wr_resp$CLR = 1'b0 ;

  // submodule f_from_host
  assign f_from_host$D_IN = from_host_put ;
  assign f_from_host$ENQ = EN_from_host_put ;
  assign f_from_host$DEQ = CAN_FIRE_RL_rl_forward_rd_rsp ;
  assign f_from_host$CLR = 1'b0 ;

  // submodule f_rsps_pending
  assign f_rsps_pending$D_IN =
	     { 1'b0,
	       axi4_S_xactor_f_rd_addr$D_OUT[60:29],
	       axi4_S_xactor_f_rd_addr$D_OUT[108:93] } ;
  assign f_rsps_pending$ENQ = CAN_FIRE_RL_rl_forward_rd_req_addr ;
  assign f_rsps_pending$DEQ = CAN_FIRE_RL_rl_forward_rd_rsp ;
  assign f_rsps_pending$CLR = 1'b0 ;

  // submodule f_to_host
  always@(WILL_FIRE_RL_rl_forward_rd_req_addr or
	  MUX_f_to_host$enq_1__VAL_1 or
	  WILL_FIRE_RL_rl_forward_wr_req_addr or
	  MUX_f_to_host$enq_1__VAL_2 or
	  WILL_FIRE_RL_rl_forward_wr_req_data or MUX_f_to_host$enq_1__VAL_3)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_rl_forward_rd_req_addr:
	  f_to_host$D_IN = MUX_f_to_host$enq_1__VAL_1;
      WILL_FIRE_RL_rl_forward_wr_req_addr:
	  f_to_host$D_IN = MUX_f_to_host$enq_1__VAL_2;
      WILL_FIRE_RL_rl_forward_wr_req_data:
	  f_to_host$D_IN = MUX_f_to_host$enq_1__VAL_3;
      default: f_to_host$D_IN = 32'hAAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign f_to_host$ENQ =
	     WILL_FIRE_RL_rl_forward_rd_req_addr ||
	     WILL_FIRE_RL_rl_forward_wr_req_addr ||
	     WILL_FIRE_RL_rl_forward_wr_req_data ;
  assign f_to_host$DEQ = EN_to_host_get ;
  assign f_to_host$CLR = 1'b0 ;

  // remaining internal signals
  assign _theResult____h1716 =
	     (f_rsps_pending$D_OUT[18:16] == 3'b100) ?
	       { f_from_host$D_OUT, 32'd0 } :
	       { 32'd0, f_from_host$D_OUT } ;
  assign rg_wdata_pending_BITS_31_TO_0__q1 = rg_wdata_pending[31:0] ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rg_wdata_pending <= `BSV_ASSIGNMENT_DELAY 33'h0AAAAAAAA;
      end
    else
      begin
        if (rg_wdata_pending$EN)
	  rg_wdata_pending <= `BSV_ASSIGNMENT_DELAY rg_wdata_pending$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rg_wdata_pending = 33'h0AAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_forward_rd_req_addr &&
	  axi4_S_xactor_f_rd_addr$D_OUT[92:61] != 32'd0)
	$display("ERROR: MMIO_to_Host:rl_forward_rd_req_addr: > 32-bit addr: 0x%0h",
		 axi4_S_xactor_f_rd_addr$D_OUT[92:29]);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_forward_wr_req_addr &&
	  axi4_S_xactor_f_wr_addr$D_OUT[92:61] != 32'd0)
	$display("ERROR: MMIO_to_Host:rl_forward_wr_req_addr: > 32-bit addr: 0x%0h",
		 axi4_S_xactor_f_wr_addr$D_OUT[92:29]);
  end
  // synopsys translate_on
endmodule  // mkMMIO_to_Host

