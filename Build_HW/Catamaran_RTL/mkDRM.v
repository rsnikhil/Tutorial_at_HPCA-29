//
// Generated by Bluespec Compiler, version 2023.01 (build 52adafa5)
//
//
// Ports:
// Name                         I/O  size props
// axi4L_S_awready                O     1 reg
// axi4L_S_wready                 O     1 reg
// axi4L_S_bvalid                 O     1 reg
// axi4L_S_bresp                  O     2 reg
// axi4L_S_arready                O     1 reg
// axi4L_S_rvalid                 O     1 reg
// axi4L_S_rresp                  O     2 reg
// axi4L_S_rdata                  O    32 reg
// ip_enable                      O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// axi4L_S_awvalid                I     1
// axi4L_S_awaddr                 I    32 reg
// axi4L_S_awprot                 I     3 reg
// axi4L_S_wvalid                 I     1
// axi4L_S_wdata                  I    32 reg
// axi4L_S_wstrb                  I     4 reg
// axi4L_S_bready                 I     1
// axi4L_S_arvalid                I     1
// axi4L_S_araddr                 I    32 reg
// axi4L_S_arprot                 I     3 reg
// axi4L_S_rready                 I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkDRM(CLK,
	     RST_N,

	     axi4L_S_awvalid,
	     axi4L_S_awaddr,
	     axi4L_S_awprot,

	     axi4L_S_awready,

	     axi4L_S_wvalid,
	     axi4L_S_wdata,
	     axi4L_S_wstrb,

	     axi4L_S_wready,

	     axi4L_S_bvalid,

	     axi4L_S_bresp,

	     axi4L_S_bready,

	     axi4L_S_arvalid,
	     axi4L_S_araddr,
	     axi4L_S_arprot,

	     axi4L_S_arready,

	     axi4L_S_rvalid,

	     axi4L_S_rresp,

	     axi4L_S_rdata,

	     axi4L_S_rready,

	     ip_enable);
  input  CLK;
  input  RST_N;

  // action method axi4L_S_m_awvalid
  input  axi4L_S_awvalid;
  input  [31 : 0] axi4L_S_awaddr;
  input  [2 : 0] axi4L_S_awprot;

  // value method axi4L_S_m_awready
  output axi4L_S_awready;

  // action method axi4L_S_m_wvalid
  input  axi4L_S_wvalid;
  input  [31 : 0] axi4L_S_wdata;
  input  [3 : 0] axi4L_S_wstrb;

  // value method axi4L_S_m_wready
  output axi4L_S_wready;

  // value method axi4L_S_m_bvalid
  output axi4L_S_bvalid;

  // value method axi4L_S_m_bresp
  output [1 : 0] axi4L_S_bresp;

  // value method axi4L_S_m_buser

  // action method axi4L_S_m_bready
  input  axi4L_S_bready;

  // action method axi4L_S_m_arvalid
  input  axi4L_S_arvalid;
  input  [31 : 0] axi4L_S_araddr;
  input  [2 : 0] axi4L_S_arprot;

  // value method axi4L_S_m_arready
  output axi4L_S_arready;

  // value method axi4L_S_m_rvalid
  output axi4L_S_rvalid;

  // value method axi4L_S_m_rresp
  output [1 : 0] axi4L_S_rresp;

  // value method axi4L_S_m_rdata
  output [31 : 0] axi4L_S_rdata;

  // value method axi4L_S_m_ruser

  // action method axi4L_S_m_rready
  input  axi4L_S_rready;

  // value method ip_enable
  output ip_enable;

  // signals for module outputs
  wire [31 : 0] axi4L_S_rdata;
  wire [1 : 0] axi4L_S_bresp, axi4L_S_rresp;
  wire axi4L_S_arready,
       axi4L_S_awready,
       axi4L_S_bvalid,
       axi4L_S_rvalid,
       axi4L_S_wready,
       ip_enable;

  // register rg_data
  reg [31 : 0] rg_data;
  wire [31 : 0] rg_data$D_IN;
  wire rg_data$EN;

  // ports of submodule axi4L_S_xactor_f_rd_addr
  wire [34 : 0] axi4L_S_xactor_f_rd_addr$D_IN, axi4L_S_xactor_f_rd_addr$D_OUT;
  wire axi4L_S_xactor_f_rd_addr$CLR,
       axi4L_S_xactor_f_rd_addr$DEQ,
       axi4L_S_xactor_f_rd_addr$EMPTY_N,
       axi4L_S_xactor_f_rd_addr$ENQ,
       axi4L_S_xactor_f_rd_addr$FULL_N;

  // ports of submodule axi4L_S_xactor_f_rd_data
  wire [33 : 0] axi4L_S_xactor_f_rd_data$D_IN, axi4L_S_xactor_f_rd_data$D_OUT;
  wire axi4L_S_xactor_f_rd_data$CLR,
       axi4L_S_xactor_f_rd_data$DEQ,
       axi4L_S_xactor_f_rd_data$EMPTY_N,
       axi4L_S_xactor_f_rd_data$ENQ,
       axi4L_S_xactor_f_rd_data$FULL_N;

  // ports of submodule axi4L_S_xactor_f_wr_addr
  wire [34 : 0] axi4L_S_xactor_f_wr_addr$D_IN, axi4L_S_xactor_f_wr_addr$D_OUT;
  wire axi4L_S_xactor_f_wr_addr$CLR,
       axi4L_S_xactor_f_wr_addr$DEQ,
       axi4L_S_xactor_f_wr_addr$EMPTY_N,
       axi4L_S_xactor_f_wr_addr$ENQ,
       axi4L_S_xactor_f_wr_addr$FULL_N;

  // ports of submodule axi4L_S_xactor_f_wr_data
  wire [35 : 0] axi4L_S_xactor_f_wr_data$D_IN, axi4L_S_xactor_f_wr_data$D_OUT;
  wire axi4L_S_xactor_f_wr_data$CLR,
       axi4L_S_xactor_f_wr_data$DEQ,
       axi4L_S_xactor_f_wr_data$EMPTY_N,
       axi4L_S_xactor_f_wr_data$ENQ,
       axi4L_S_xactor_f_wr_data$FULL_N;

  // ports of submodule axi4L_S_xactor_f_wr_resp
  wire [1 : 0] axi4L_S_xactor_f_wr_resp$D_IN, axi4L_S_xactor_f_wr_resp$D_OUT;
  wire axi4L_S_xactor_f_wr_resp$CLR,
       axi4L_S_xactor_f_wr_resp$DEQ,
       axi4L_S_xactor_f_wr_resp$EMPTY_N,
       axi4L_S_xactor_f_wr_resp$ENQ,
       axi4L_S_xactor_f_wr_resp$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_rl_rd_xaction,
       CAN_FIRE_RL_rl_wr_xaction,
       CAN_FIRE_axi4L_S_m_arvalid,
       CAN_FIRE_axi4L_S_m_awvalid,
       CAN_FIRE_axi4L_S_m_bready,
       CAN_FIRE_axi4L_S_m_rready,
       CAN_FIRE_axi4L_S_m_wvalid,
       WILL_FIRE_RL_rl_rd_xaction,
       WILL_FIRE_RL_rl_wr_xaction,
       WILL_FIRE_axi4L_S_m_arvalid,
       WILL_FIRE_axi4L_S_m_awvalid,
       WILL_FIRE_axi4L_S_m_bready,
       WILL_FIRE_axi4L_S_m_rready,
       WILL_FIRE_axi4L_S_m_wvalid;

  // action method axi4L_S_m_awvalid
  assign CAN_FIRE_axi4L_S_m_awvalid = 1'd1 ;
  assign WILL_FIRE_axi4L_S_m_awvalid = 1'd1 ;

  // value method axi4L_S_m_awready
  assign axi4L_S_awready = axi4L_S_xactor_f_wr_addr$FULL_N ;

  // action method axi4L_S_m_wvalid
  assign CAN_FIRE_axi4L_S_m_wvalid = 1'd1 ;
  assign WILL_FIRE_axi4L_S_m_wvalid = 1'd1 ;

  // value method axi4L_S_m_wready
  assign axi4L_S_wready = axi4L_S_xactor_f_wr_data$FULL_N ;

  // value method axi4L_S_m_bvalid
  assign axi4L_S_bvalid = axi4L_S_xactor_f_wr_resp$EMPTY_N ;

  // value method axi4L_S_m_bresp
  assign axi4L_S_bresp = axi4L_S_xactor_f_wr_resp$D_OUT ;

  // action method axi4L_S_m_bready
  assign CAN_FIRE_axi4L_S_m_bready = 1'd1 ;
  assign WILL_FIRE_axi4L_S_m_bready = 1'd1 ;

  // action method axi4L_S_m_arvalid
  assign CAN_FIRE_axi4L_S_m_arvalid = 1'd1 ;
  assign WILL_FIRE_axi4L_S_m_arvalid = 1'd1 ;

  // value method axi4L_S_m_arready
  assign axi4L_S_arready = axi4L_S_xactor_f_rd_addr$FULL_N ;

  // value method axi4L_S_m_rvalid
  assign axi4L_S_rvalid = axi4L_S_xactor_f_rd_data$EMPTY_N ;

  // value method axi4L_S_m_rresp
  assign axi4L_S_rresp = axi4L_S_xactor_f_rd_data$D_OUT[33:32] ;

  // value method axi4L_S_m_rdata
  assign axi4L_S_rdata = axi4L_S_xactor_f_rd_data$D_OUT[31:0] ;

  // action method axi4L_S_m_rready
  assign CAN_FIRE_axi4L_S_m_rready = 1'd1 ;
  assign WILL_FIRE_axi4L_S_m_rready = 1'd1 ;

  // value method ip_enable
  assign ip_enable = rg_data[0] ;

  // submodule axi4L_S_xactor_f_rd_addr
  FIFO2 #(.width(32'd35),
	  .guarded(1'd1)) axi4L_S_xactor_f_rd_addr(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(axi4L_S_xactor_f_rd_addr$D_IN),
						   .ENQ(axi4L_S_xactor_f_rd_addr$ENQ),
						   .DEQ(axi4L_S_xactor_f_rd_addr$DEQ),
						   .CLR(axi4L_S_xactor_f_rd_addr$CLR),
						   .D_OUT(axi4L_S_xactor_f_rd_addr$D_OUT),
						   .FULL_N(axi4L_S_xactor_f_rd_addr$FULL_N),
						   .EMPTY_N(axi4L_S_xactor_f_rd_addr$EMPTY_N));

  // submodule axi4L_S_xactor_f_rd_data
  FIFO2 #(.width(32'd34),
	  .guarded(1'd1)) axi4L_S_xactor_f_rd_data(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(axi4L_S_xactor_f_rd_data$D_IN),
						   .ENQ(axi4L_S_xactor_f_rd_data$ENQ),
						   .DEQ(axi4L_S_xactor_f_rd_data$DEQ),
						   .CLR(axi4L_S_xactor_f_rd_data$CLR),
						   .D_OUT(axi4L_S_xactor_f_rd_data$D_OUT),
						   .FULL_N(axi4L_S_xactor_f_rd_data$FULL_N),
						   .EMPTY_N(axi4L_S_xactor_f_rd_data$EMPTY_N));

  // submodule axi4L_S_xactor_f_wr_addr
  FIFO2 #(.width(32'd35),
	  .guarded(1'd1)) axi4L_S_xactor_f_wr_addr(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(axi4L_S_xactor_f_wr_addr$D_IN),
						   .ENQ(axi4L_S_xactor_f_wr_addr$ENQ),
						   .DEQ(axi4L_S_xactor_f_wr_addr$DEQ),
						   .CLR(axi4L_S_xactor_f_wr_addr$CLR),
						   .D_OUT(axi4L_S_xactor_f_wr_addr$D_OUT),
						   .FULL_N(axi4L_S_xactor_f_wr_addr$FULL_N),
						   .EMPTY_N(axi4L_S_xactor_f_wr_addr$EMPTY_N));

  // submodule axi4L_S_xactor_f_wr_data
  FIFO2 #(.width(32'd36),
	  .guarded(1'd1)) axi4L_S_xactor_f_wr_data(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(axi4L_S_xactor_f_wr_data$D_IN),
						   .ENQ(axi4L_S_xactor_f_wr_data$ENQ),
						   .DEQ(axi4L_S_xactor_f_wr_data$DEQ),
						   .CLR(axi4L_S_xactor_f_wr_data$CLR),
						   .D_OUT(axi4L_S_xactor_f_wr_data$D_OUT),
						   .FULL_N(axi4L_S_xactor_f_wr_data$FULL_N),
						   .EMPTY_N(axi4L_S_xactor_f_wr_data$EMPTY_N));

  // submodule axi4L_S_xactor_f_wr_resp
  FIFO2 #(.width(32'd2), .guarded(1'd1)) axi4L_S_xactor_f_wr_resp(.RST(RST_N),
								  .CLK(CLK),
								  .D_IN(axi4L_S_xactor_f_wr_resp$D_IN),
								  .ENQ(axi4L_S_xactor_f_wr_resp$ENQ),
								  .DEQ(axi4L_S_xactor_f_wr_resp$DEQ),
								  .CLR(axi4L_S_xactor_f_wr_resp$CLR),
								  .D_OUT(axi4L_S_xactor_f_wr_resp$D_OUT),
								  .FULL_N(axi4L_S_xactor_f_wr_resp$FULL_N),
								  .EMPTY_N(axi4L_S_xactor_f_wr_resp$EMPTY_N));

  // rule RL_rl_rd_xaction
  assign CAN_FIRE_RL_rl_rd_xaction =
	     axi4L_S_xactor_f_rd_addr$EMPTY_N &&
	     axi4L_S_xactor_f_rd_data$FULL_N ;
  assign WILL_FIRE_RL_rl_rd_xaction = CAN_FIRE_RL_rl_rd_xaction ;

  // rule RL_rl_wr_xaction
  assign CAN_FIRE_RL_rl_wr_xaction =
	     axi4L_S_xactor_f_wr_addr$EMPTY_N &&
	     axi4L_S_xactor_f_wr_data$EMPTY_N &&
	     axi4L_S_xactor_f_wr_resp$FULL_N ;
  assign WILL_FIRE_RL_rl_wr_xaction = CAN_FIRE_RL_rl_wr_xaction ;

  // register rg_data
  assign rg_data$D_IN = axi4L_S_xactor_f_wr_data$D_OUT[35:4] ;
  assign rg_data$EN =
	     WILL_FIRE_RL_rl_wr_xaction &&
	     axi4L_S_xactor_f_wr_addr$D_OUT[4:3] == 2'd0 ;

  // submodule axi4L_S_xactor_f_rd_addr
  assign axi4L_S_xactor_f_rd_addr$D_IN = { axi4L_S_araddr, axi4L_S_arprot } ;
  assign axi4L_S_xactor_f_rd_addr$ENQ =
	     axi4L_S_arvalid && axi4L_S_xactor_f_rd_addr$FULL_N ;
  assign axi4L_S_xactor_f_rd_addr$DEQ = CAN_FIRE_RL_rl_rd_xaction ;
  assign axi4L_S_xactor_f_rd_addr$CLR = 1'b0 ;

  // submodule axi4L_S_xactor_f_rd_data
  assign axi4L_S_xactor_f_rd_data$D_IN =
	     (axi4L_S_xactor_f_rd_addr$D_OUT[4:3] == 2'd0) ?
	       { axi4L_S_xactor_f_rd_addr$D_OUT[4:3], rg_data } :
	       34'h289ABCDEF ;
  assign axi4L_S_xactor_f_rd_data$ENQ = CAN_FIRE_RL_rl_rd_xaction ;
  assign axi4L_S_xactor_f_rd_data$DEQ =
	     axi4L_S_rready && axi4L_S_xactor_f_rd_data$EMPTY_N ;
  assign axi4L_S_xactor_f_rd_data$CLR = 1'b0 ;

  // submodule axi4L_S_xactor_f_wr_addr
  assign axi4L_S_xactor_f_wr_addr$D_IN = { axi4L_S_awaddr, axi4L_S_awprot } ;
  assign axi4L_S_xactor_f_wr_addr$ENQ =
	     axi4L_S_awvalid && axi4L_S_xactor_f_wr_addr$FULL_N ;
  assign axi4L_S_xactor_f_wr_addr$DEQ = CAN_FIRE_RL_rl_wr_xaction ;
  assign axi4L_S_xactor_f_wr_addr$CLR = 1'b0 ;

  // submodule axi4L_S_xactor_f_wr_data
  assign axi4L_S_xactor_f_wr_data$D_IN = { axi4L_S_wdata, axi4L_S_wstrb } ;
  assign axi4L_S_xactor_f_wr_data$ENQ =
	     axi4L_S_wvalid && axi4L_S_xactor_f_wr_data$FULL_N ;
  assign axi4L_S_xactor_f_wr_data$DEQ = CAN_FIRE_RL_rl_wr_xaction ;
  assign axi4L_S_xactor_f_wr_data$CLR = 1'b0 ;

  // submodule axi4L_S_xactor_f_wr_resp
  assign axi4L_S_xactor_f_wr_resp$D_IN =
	     (axi4L_S_xactor_f_wr_addr$D_OUT[4:3] == 2'd0) ?
	       axi4L_S_xactor_f_wr_addr$D_OUT[4:3] :
	       2'd2 ;
  assign axi4L_S_xactor_f_wr_resp$ENQ = CAN_FIRE_RL_rl_wr_xaction ;
  assign axi4L_S_xactor_f_wr_resp$DEQ =
	     axi4L_S_bready && axi4L_S_xactor_f_wr_resp$EMPTY_N ;
  assign axi4L_S_xactor_f_wr_resp$CLR = 1'b0 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rg_data <= `BSV_ASSIGNMENT_DELAY 32'd1;
      end
    else
      begin
        if (rg_data$EN) rg_data <= `BSV_ASSIGNMENT_DELAY rg_data$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rg_data = 32'hAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkDRM

