//
// Generated by Bluespec Compiler, version 2023.01 (build 52adafa5)
//
//
// Ports:
// Name                         I/O  size props
// axi4L_S_awready                O     1 reg
// axi4L_S_wready                 O     1 reg
// axi4L_S_bvalid                 O     1 reg
// axi4L_S_bresp                  O     2 reg
// axi4L_S_arready                O     1 reg
// axi4L_S_rvalid                 O     1 reg
// axi4L_S_rresp                  O     2 reg
// axi4L_S_rdata                  O    32 reg
// axi4L_M_awvalid                O     1 reg
// axi4L_M_awaddr                 O    32 reg
// axi4L_M_awprot                 O     3 reg
// axi4L_M_wvalid                 O     1 reg
// axi4L_M_wdata                  O    32 reg
// axi4L_M_wstrb                  O     4 reg
// axi4L_M_bready                 O     1 reg
// axi4L_M_arvalid                O     1 reg
// axi4L_M_araddr                 O    32 reg
// axi4L_M_arprot                 O     3 reg
// axi4L_M_rready                 O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// axi4L_S_awvalid                I     1
// axi4L_S_awaddr                 I    32 reg
// axi4L_S_awprot                 I     3 reg
// axi4L_S_wvalid                 I     1
// axi4L_S_wdata                  I    32 reg
// axi4L_S_wstrb                  I     4 reg
// axi4L_S_bready                 I     1
// axi4L_S_arvalid                I     1
// axi4L_S_araddr                 I    32 reg
// axi4L_S_arprot                 I     3 reg
// axi4L_S_rready                 I     1
// axi4L_M_awready                I     1
// axi4L_M_wready                 I     1
// axi4L_M_bvalid                 I     1
// axi4L_M_bresp                  I     2 reg
// axi4L_M_arready                I     1
// axi4L_M_rvalid                 I     1
// axi4L_M_rresp                  I     2 reg
// axi4L_M_rdata                  I    32 reg
// m_enable_enabled               I     1 reg
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkAXI4L_Gate_A(CLK,
		      RST_N,

		      axi4L_S_awvalid,
		      axi4L_S_awaddr,
		      axi4L_S_awprot,

		      axi4L_S_awready,

		      axi4L_S_wvalid,
		      axi4L_S_wdata,
		      axi4L_S_wstrb,

		      axi4L_S_wready,

		      axi4L_S_bvalid,

		      axi4L_S_bresp,

		      axi4L_S_bready,

		      axi4L_S_arvalid,
		      axi4L_S_araddr,
		      axi4L_S_arprot,

		      axi4L_S_arready,

		      axi4L_S_rvalid,

		      axi4L_S_rresp,

		      axi4L_S_rdata,

		      axi4L_S_rready,

		      axi4L_M_awvalid,

		      axi4L_M_awaddr,

		      axi4L_M_awprot,

		      axi4L_M_awready,

		      axi4L_M_wvalid,

		      axi4L_M_wdata,

		      axi4L_M_wstrb,

		      axi4L_M_wready,

		      axi4L_M_bvalid,
		      axi4L_M_bresp,

		      axi4L_M_bready,

		      axi4L_M_arvalid,

		      axi4L_M_araddr,

		      axi4L_M_arprot,

		      axi4L_M_arready,

		      axi4L_M_rvalid,
		      axi4L_M_rresp,
		      axi4L_M_rdata,

		      axi4L_M_rready,

		      m_enable_enabled);
  input  CLK;
  input  RST_N;

  // action method axi4L_S_m_awvalid
  input  axi4L_S_awvalid;
  input  [31 : 0] axi4L_S_awaddr;
  input  [2 : 0] axi4L_S_awprot;

  // value method axi4L_S_m_awready
  output axi4L_S_awready;

  // action method axi4L_S_m_wvalid
  input  axi4L_S_wvalid;
  input  [31 : 0] axi4L_S_wdata;
  input  [3 : 0] axi4L_S_wstrb;

  // value method axi4L_S_m_wready
  output axi4L_S_wready;

  // value method axi4L_S_m_bvalid
  output axi4L_S_bvalid;

  // value method axi4L_S_m_bresp
  output [1 : 0] axi4L_S_bresp;

  // value method axi4L_S_m_buser

  // action method axi4L_S_m_bready
  input  axi4L_S_bready;

  // action method axi4L_S_m_arvalid
  input  axi4L_S_arvalid;
  input  [31 : 0] axi4L_S_araddr;
  input  [2 : 0] axi4L_S_arprot;

  // value method axi4L_S_m_arready
  output axi4L_S_arready;

  // value method axi4L_S_m_rvalid
  output axi4L_S_rvalid;

  // value method axi4L_S_m_rresp
  output [1 : 0] axi4L_S_rresp;

  // value method axi4L_S_m_rdata
  output [31 : 0] axi4L_S_rdata;

  // value method axi4L_S_m_ruser

  // action method axi4L_S_m_rready
  input  axi4L_S_rready;

  // value method axi4L_M_m_awvalid
  output axi4L_M_awvalid;

  // value method axi4L_M_m_awaddr
  output [31 : 0] axi4L_M_awaddr;

  // value method axi4L_M_m_awprot
  output [2 : 0] axi4L_M_awprot;

  // value method axi4L_M_m_awuser

  // action method axi4L_M_m_awready
  input  axi4L_M_awready;

  // value method axi4L_M_m_wvalid
  output axi4L_M_wvalid;

  // value method axi4L_M_m_wdata
  output [31 : 0] axi4L_M_wdata;

  // value method axi4L_M_m_wstrb
  output [3 : 0] axi4L_M_wstrb;

  // action method axi4L_M_m_wready
  input  axi4L_M_wready;

  // action method axi4L_M_m_bvalid
  input  axi4L_M_bvalid;
  input  [1 : 0] axi4L_M_bresp;

  // value method axi4L_M_m_bready
  output axi4L_M_bready;

  // value method axi4L_M_m_arvalid
  output axi4L_M_arvalid;

  // value method axi4L_M_m_araddr
  output [31 : 0] axi4L_M_araddr;

  // value method axi4L_M_m_arprot
  output [2 : 0] axi4L_M_arprot;

  // value method axi4L_M_m_aruser

  // action method axi4L_M_m_arready
  input  axi4L_M_arready;

  // action method axi4L_M_m_rvalid
  input  axi4L_M_rvalid;
  input  [1 : 0] axi4L_M_rresp;
  input  [31 : 0] axi4L_M_rdata;

  // value method axi4L_M_m_rready
  output axi4L_M_rready;

  // action method m_enable
  input  m_enable_enabled;

  // signals for module outputs
  wire [31 : 0] axi4L_M_araddr, axi4L_M_awaddr, axi4L_M_wdata, axi4L_S_rdata;
  wire [3 : 0] axi4L_M_wstrb;
  wire [2 : 0] axi4L_M_arprot, axi4L_M_awprot;
  wire [1 : 0] axi4L_S_bresp, axi4L_S_rresp;
  wire axi4L_M_arvalid,
       axi4L_M_awvalid,
       axi4L_M_bready,
       axi4L_M_rready,
       axi4L_M_wvalid,
       axi4L_S_arready,
       axi4L_S_awready,
       axi4L_S_bvalid,
       axi4L_S_rvalid,
       axi4L_S_wready;

  // register m_rg_enabled
  reg m_rg_enabled;
  wire m_rg_enabled$D_IN, m_rg_enabled$EN;

  // ports of submodule m_xactor_from_M_f_rd_addr
  wire [34 : 0] m_xactor_from_M_f_rd_addr$D_IN,
		m_xactor_from_M_f_rd_addr$D_OUT;
  wire m_xactor_from_M_f_rd_addr$CLR,
       m_xactor_from_M_f_rd_addr$DEQ,
       m_xactor_from_M_f_rd_addr$EMPTY_N,
       m_xactor_from_M_f_rd_addr$ENQ,
       m_xactor_from_M_f_rd_addr$FULL_N;

  // ports of submodule m_xactor_from_M_f_rd_data
  wire [33 : 0] m_xactor_from_M_f_rd_data$D_IN,
		m_xactor_from_M_f_rd_data$D_OUT;
  wire m_xactor_from_M_f_rd_data$CLR,
       m_xactor_from_M_f_rd_data$DEQ,
       m_xactor_from_M_f_rd_data$EMPTY_N,
       m_xactor_from_M_f_rd_data$ENQ,
       m_xactor_from_M_f_rd_data$FULL_N;

  // ports of submodule m_xactor_from_M_f_wr_addr
  wire [34 : 0] m_xactor_from_M_f_wr_addr$D_IN,
		m_xactor_from_M_f_wr_addr$D_OUT;
  wire m_xactor_from_M_f_wr_addr$CLR,
       m_xactor_from_M_f_wr_addr$DEQ,
       m_xactor_from_M_f_wr_addr$EMPTY_N,
       m_xactor_from_M_f_wr_addr$ENQ,
       m_xactor_from_M_f_wr_addr$FULL_N;

  // ports of submodule m_xactor_from_M_f_wr_data
  wire [35 : 0] m_xactor_from_M_f_wr_data$D_IN,
		m_xactor_from_M_f_wr_data$D_OUT;
  wire m_xactor_from_M_f_wr_data$CLR,
       m_xactor_from_M_f_wr_data$DEQ,
       m_xactor_from_M_f_wr_data$EMPTY_N,
       m_xactor_from_M_f_wr_data$ENQ,
       m_xactor_from_M_f_wr_data$FULL_N;

  // ports of submodule m_xactor_from_M_f_wr_resp
  wire [1 : 0] m_xactor_from_M_f_wr_resp$D_IN,
	       m_xactor_from_M_f_wr_resp$D_OUT;
  wire m_xactor_from_M_f_wr_resp$CLR,
       m_xactor_from_M_f_wr_resp$DEQ,
       m_xactor_from_M_f_wr_resp$EMPTY_N,
       m_xactor_from_M_f_wr_resp$ENQ,
       m_xactor_from_M_f_wr_resp$FULL_N;

  // ports of submodule m_xactor_to_S_f_rd_addr
  wire [34 : 0] m_xactor_to_S_f_rd_addr$D_IN, m_xactor_to_S_f_rd_addr$D_OUT;
  wire m_xactor_to_S_f_rd_addr$CLR,
       m_xactor_to_S_f_rd_addr$DEQ,
       m_xactor_to_S_f_rd_addr$EMPTY_N,
       m_xactor_to_S_f_rd_addr$ENQ,
       m_xactor_to_S_f_rd_addr$FULL_N;

  // ports of submodule m_xactor_to_S_f_rd_data
  wire [33 : 0] m_xactor_to_S_f_rd_data$D_IN, m_xactor_to_S_f_rd_data$D_OUT;
  wire m_xactor_to_S_f_rd_data$CLR,
       m_xactor_to_S_f_rd_data$DEQ,
       m_xactor_to_S_f_rd_data$EMPTY_N,
       m_xactor_to_S_f_rd_data$ENQ,
       m_xactor_to_S_f_rd_data$FULL_N;

  // ports of submodule m_xactor_to_S_f_wr_addr
  wire [34 : 0] m_xactor_to_S_f_wr_addr$D_IN, m_xactor_to_S_f_wr_addr$D_OUT;
  wire m_xactor_to_S_f_wr_addr$CLR,
       m_xactor_to_S_f_wr_addr$DEQ,
       m_xactor_to_S_f_wr_addr$EMPTY_N,
       m_xactor_to_S_f_wr_addr$ENQ,
       m_xactor_to_S_f_wr_addr$FULL_N;

  // ports of submodule m_xactor_to_S_f_wr_data
  wire [35 : 0] m_xactor_to_S_f_wr_data$D_IN, m_xactor_to_S_f_wr_data$D_OUT;
  wire m_xactor_to_S_f_wr_data$CLR,
       m_xactor_to_S_f_wr_data$DEQ,
       m_xactor_to_S_f_wr_data$EMPTY_N,
       m_xactor_to_S_f_wr_data$ENQ,
       m_xactor_to_S_f_wr_data$FULL_N;

  // ports of submodule m_xactor_to_S_f_wr_resp
  wire [1 : 0] m_xactor_to_S_f_wr_resp$D_IN, m_xactor_to_S_f_wr_resp$D_OUT;
  wire m_xactor_to_S_f_wr_resp$CLR,
       m_xactor_to_S_f_wr_resp$DEQ,
       m_xactor_to_S_f_wr_resp$EMPTY_N,
       m_xactor_to_S_f_wr_resp$ENQ,
       m_xactor_to_S_f_wr_resp$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_m_rl_rd_addr,
       CAN_FIRE_RL_m_rl_rd_addr_disabled,
       CAN_FIRE_RL_m_rl_rd_data,
       CAN_FIRE_RL_m_rl_rd_data_disabled_drain_S,
       CAN_FIRE_RL_m_rl_wr_addr,
       CAN_FIRE_RL_m_rl_wr_addr_disabled,
       CAN_FIRE_RL_m_rl_wr_data,
       CAN_FIRE_RL_m_rl_wr_data_disabled,
       CAN_FIRE_RL_m_rl_wr_resp,
       CAN_FIRE_RL_m_rl_wr_resp_disabled_drain_S,
       CAN_FIRE_axi4L_M_m_arready,
       CAN_FIRE_axi4L_M_m_awready,
       CAN_FIRE_axi4L_M_m_bvalid,
       CAN_FIRE_axi4L_M_m_rvalid,
       CAN_FIRE_axi4L_M_m_wready,
       CAN_FIRE_axi4L_S_m_arvalid,
       CAN_FIRE_axi4L_S_m_awvalid,
       CAN_FIRE_axi4L_S_m_bready,
       CAN_FIRE_axi4L_S_m_rready,
       CAN_FIRE_axi4L_S_m_wvalid,
       CAN_FIRE_m_enable,
       WILL_FIRE_RL_m_rl_rd_addr,
       WILL_FIRE_RL_m_rl_rd_addr_disabled,
       WILL_FIRE_RL_m_rl_rd_data,
       WILL_FIRE_RL_m_rl_rd_data_disabled_drain_S,
       WILL_FIRE_RL_m_rl_wr_addr,
       WILL_FIRE_RL_m_rl_wr_addr_disabled,
       WILL_FIRE_RL_m_rl_wr_data,
       WILL_FIRE_RL_m_rl_wr_data_disabled,
       WILL_FIRE_RL_m_rl_wr_resp,
       WILL_FIRE_RL_m_rl_wr_resp_disabled_drain_S,
       WILL_FIRE_axi4L_M_m_arready,
       WILL_FIRE_axi4L_M_m_awready,
       WILL_FIRE_axi4L_M_m_bvalid,
       WILL_FIRE_axi4L_M_m_rvalid,
       WILL_FIRE_axi4L_M_m_wready,
       WILL_FIRE_axi4L_S_m_arvalid,
       WILL_FIRE_axi4L_S_m_awvalid,
       WILL_FIRE_axi4L_S_m_bready,
       WILL_FIRE_axi4L_S_m_rready,
       WILL_FIRE_axi4L_S_m_wvalid,
       WILL_FIRE_m_enable;

  // declarations used by system tasks
  // synopsys translate_off
  reg [31 : 0] v__h1597;
  reg [31 : 0] v__h1761;
  reg [31 : 0] v__h1960;
  reg [31 : 0] v__h2087;
  reg [31 : 0] v__h1591;
  reg [31 : 0] v__h1755;
  reg [31 : 0] v__h1954;
  reg [31 : 0] v__h2081;
  // synopsys translate_on

  // action method axi4L_S_m_awvalid
  assign CAN_FIRE_axi4L_S_m_awvalid = 1'd1 ;
  assign WILL_FIRE_axi4L_S_m_awvalid = 1'd1 ;

  // value method axi4L_S_m_awready
  assign axi4L_S_awready = m_xactor_from_M_f_wr_addr$FULL_N ;

  // action method axi4L_S_m_wvalid
  assign CAN_FIRE_axi4L_S_m_wvalid = 1'd1 ;
  assign WILL_FIRE_axi4L_S_m_wvalid = 1'd1 ;

  // value method axi4L_S_m_wready
  assign axi4L_S_wready = m_xactor_from_M_f_wr_data$FULL_N ;

  // value method axi4L_S_m_bvalid
  assign axi4L_S_bvalid = m_xactor_from_M_f_wr_resp$EMPTY_N ;

  // value method axi4L_S_m_bresp
  assign axi4L_S_bresp = m_xactor_from_M_f_wr_resp$D_OUT ;

  // action method axi4L_S_m_bready
  assign CAN_FIRE_axi4L_S_m_bready = 1'd1 ;
  assign WILL_FIRE_axi4L_S_m_bready = 1'd1 ;

  // action method axi4L_S_m_arvalid
  assign CAN_FIRE_axi4L_S_m_arvalid = 1'd1 ;
  assign WILL_FIRE_axi4L_S_m_arvalid = 1'd1 ;

  // value method axi4L_S_m_arready
  assign axi4L_S_arready = m_xactor_from_M_f_rd_addr$FULL_N ;

  // value method axi4L_S_m_rvalid
  assign axi4L_S_rvalid = m_xactor_from_M_f_rd_data$EMPTY_N ;

  // value method axi4L_S_m_rresp
  assign axi4L_S_rresp = m_xactor_from_M_f_rd_data$D_OUT[33:32] ;

  // value method axi4L_S_m_rdata
  assign axi4L_S_rdata = m_xactor_from_M_f_rd_data$D_OUT[31:0] ;

  // action method axi4L_S_m_rready
  assign CAN_FIRE_axi4L_S_m_rready = 1'd1 ;
  assign WILL_FIRE_axi4L_S_m_rready = 1'd1 ;

  // value method axi4L_M_m_awvalid
  assign axi4L_M_awvalid = m_xactor_to_S_f_wr_addr$EMPTY_N ;

  // value method axi4L_M_m_awaddr
  assign axi4L_M_awaddr = m_xactor_to_S_f_wr_addr$D_OUT[34:3] ;

  // value method axi4L_M_m_awprot
  assign axi4L_M_awprot = m_xactor_to_S_f_wr_addr$D_OUT[2:0] ;

  // action method axi4L_M_m_awready
  assign CAN_FIRE_axi4L_M_m_awready = 1'd1 ;
  assign WILL_FIRE_axi4L_M_m_awready = 1'd1 ;

  // value method axi4L_M_m_wvalid
  assign axi4L_M_wvalid = m_xactor_to_S_f_wr_data$EMPTY_N ;

  // value method axi4L_M_m_wdata
  assign axi4L_M_wdata = m_xactor_to_S_f_wr_data$D_OUT[35:4] ;

  // value method axi4L_M_m_wstrb
  assign axi4L_M_wstrb = m_xactor_to_S_f_wr_data$D_OUT[3:0] ;

  // action method axi4L_M_m_wready
  assign CAN_FIRE_axi4L_M_m_wready = 1'd1 ;
  assign WILL_FIRE_axi4L_M_m_wready = 1'd1 ;

  // action method axi4L_M_m_bvalid
  assign CAN_FIRE_axi4L_M_m_bvalid = 1'd1 ;
  assign WILL_FIRE_axi4L_M_m_bvalid = 1'd1 ;

  // value method axi4L_M_m_bready
  assign axi4L_M_bready = m_xactor_to_S_f_wr_resp$FULL_N ;

  // value method axi4L_M_m_arvalid
  assign axi4L_M_arvalid = m_xactor_to_S_f_rd_addr$EMPTY_N ;

  // value method axi4L_M_m_araddr
  assign axi4L_M_araddr = m_xactor_to_S_f_rd_addr$D_OUT[34:3] ;

  // value method axi4L_M_m_arprot
  assign axi4L_M_arprot = m_xactor_to_S_f_rd_addr$D_OUT[2:0] ;

  // action method axi4L_M_m_arready
  assign CAN_FIRE_axi4L_M_m_arready = 1'd1 ;
  assign WILL_FIRE_axi4L_M_m_arready = 1'd1 ;

  // action method axi4L_M_m_rvalid
  assign CAN_FIRE_axi4L_M_m_rvalid = 1'd1 ;
  assign WILL_FIRE_axi4L_M_m_rvalid = 1'd1 ;

  // value method axi4L_M_m_rready
  assign axi4L_M_rready = m_xactor_to_S_f_rd_data$FULL_N ;

  // action method m_enable
  assign CAN_FIRE_m_enable = 1'd1 ;
  assign WILL_FIRE_m_enable = 1'd1 ;

  // submodule m_xactor_from_M_f_rd_addr
  FIFO2 #(.width(32'd35),
	  .guarded(1'd1)) m_xactor_from_M_f_rd_addr(.RST(RST_N),
						    .CLK(CLK),
						    .D_IN(m_xactor_from_M_f_rd_addr$D_IN),
						    .ENQ(m_xactor_from_M_f_rd_addr$ENQ),
						    .DEQ(m_xactor_from_M_f_rd_addr$DEQ),
						    .CLR(m_xactor_from_M_f_rd_addr$CLR),
						    .D_OUT(m_xactor_from_M_f_rd_addr$D_OUT),
						    .FULL_N(m_xactor_from_M_f_rd_addr$FULL_N),
						    .EMPTY_N(m_xactor_from_M_f_rd_addr$EMPTY_N));

  // submodule m_xactor_from_M_f_rd_data
  FIFO2 #(.width(32'd34),
	  .guarded(1'd1)) m_xactor_from_M_f_rd_data(.RST(RST_N),
						    .CLK(CLK),
						    .D_IN(m_xactor_from_M_f_rd_data$D_IN),
						    .ENQ(m_xactor_from_M_f_rd_data$ENQ),
						    .DEQ(m_xactor_from_M_f_rd_data$DEQ),
						    .CLR(m_xactor_from_M_f_rd_data$CLR),
						    .D_OUT(m_xactor_from_M_f_rd_data$D_OUT),
						    .FULL_N(m_xactor_from_M_f_rd_data$FULL_N),
						    .EMPTY_N(m_xactor_from_M_f_rd_data$EMPTY_N));

  // submodule m_xactor_from_M_f_wr_addr
  FIFO2 #(.width(32'd35),
	  .guarded(1'd1)) m_xactor_from_M_f_wr_addr(.RST(RST_N),
						    .CLK(CLK),
						    .D_IN(m_xactor_from_M_f_wr_addr$D_IN),
						    .ENQ(m_xactor_from_M_f_wr_addr$ENQ),
						    .DEQ(m_xactor_from_M_f_wr_addr$DEQ),
						    .CLR(m_xactor_from_M_f_wr_addr$CLR),
						    .D_OUT(m_xactor_from_M_f_wr_addr$D_OUT),
						    .FULL_N(m_xactor_from_M_f_wr_addr$FULL_N),
						    .EMPTY_N(m_xactor_from_M_f_wr_addr$EMPTY_N));

  // submodule m_xactor_from_M_f_wr_data
  FIFO2 #(.width(32'd36),
	  .guarded(1'd1)) m_xactor_from_M_f_wr_data(.RST(RST_N),
						    .CLK(CLK),
						    .D_IN(m_xactor_from_M_f_wr_data$D_IN),
						    .ENQ(m_xactor_from_M_f_wr_data$ENQ),
						    .DEQ(m_xactor_from_M_f_wr_data$DEQ),
						    .CLR(m_xactor_from_M_f_wr_data$CLR),
						    .D_OUT(m_xactor_from_M_f_wr_data$D_OUT),
						    .FULL_N(m_xactor_from_M_f_wr_data$FULL_N),
						    .EMPTY_N(m_xactor_from_M_f_wr_data$EMPTY_N));

  // submodule m_xactor_from_M_f_wr_resp
  FIFO2 #(.width(32'd2),
	  .guarded(1'd1)) m_xactor_from_M_f_wr_resp(.RST(RST_N),
						    .CLK(CLK),
						    .D_IN(m_xactor_from_M_f_wr_resp$D_IN),
						    .ENQ(m_xactor_from_M_f_wr_resp$ENQ),
						    .DEQ(m_xactor_from_M_f_wr_resp$DEQ),
						    .CLR(m_xactor_from_M_f_wr_resp$CLR),
						    .D_OUT(m_xactor_from_M_f_wr_resp$D_OUT),
						    .FULL_N(m_xactor_from_M_f_wr_resp$FULL_N),
						    .EMPTY_N(m_xactor_from_M_f_wr_resp$EMPTY_N));

  // submodule m_xactor_to_S_f_rd_addr
  FIFO2 #(.width(32'd35), .guarded(1'd1)) m_xactor_to_S_f_rd_addr(.RST(RST_N),
								  .CLK(CLK),
								  .D_IN(m_xactor_to_S_f_rd_addr$D_IN),
								  .ENQ(m_xactor_to_S_f_rd_addr$ENQ),
								  .DEQ(m_xactor_to_S_f_rd_addr$DEQ),
								  .CLR(m_xactor_to_S_f_rd_addr$CLR),
								  .D_OUT(m_xactor_to_S_f_rd_addr$D_OUT),
								  .FULL_N(m_xactor_to_S_f_rd_addr$FULL_N),
								  .EMPTY_N(m_xactor_to_S_f_rd_addr$EMPTY_N));

  // submodule m_xactor_to_S_f_rd_data
  FIFO2 #(.width(32'd34), .guarded(1'd1)) m_xactor_to_S_f_rd_data(.RST(RST_N),
								  .CLK(CLK),
								  .D_IN(m_xactor_to_S_f_rd_data$D_IN),
								  .ENQ(m_xactor_to_S_f_rd_data$ENQ),
								  .DEQ(m_xactor_to_S_f_rd_data$DEQ),
								  .CLR(m_xactor_to_S_f_rd_data$CLR),
								  .D_OUT(m_xactor_to_S_f_rd_data$D_OUT),
								  .FULL_N(m_xactor_to_S_f_rd_data$FULL_N),
								  .EMPTY_N(m_xactor_to_S_f_rd_data$EMPTY_N));

  // submodule m_xactor_to_S_f_wr_addr
  FIFO2 #(.width(32'd35), .guarded(1'd1)) m_xactor_to_S_f_wr_addr(.RST(RST_N),
								  .CLK(CLK),
								  .D_IN(m_xactor_to_S_f_wr_addr$D_IN),
								  .ENQ(m_xactor_to_S_f_wr_addr$ENQ),
								  .DEQ(m_xactor_to_S_f_wr_addr$DEQ),
								  .CLR(m_xactor_to_S_f_wr_addr$CLR),
								  .D_OUT(m_xactor_to_S_f_wr_addr$D_OUT),
								  .FULL_N(m_xactor_to_S_f_wr_addr$FULL_N),
								  .EMPTY_N(m_xactor_to_S_f_wr_addr$EMPTY_N));

  // submodule m_xactor_to_S_f_wr_data
  FIFO2 #(.width(32'd36), .guarded(1'd1)) m_xactor_to_S_f_wr_data(.RST(RST_N),
								  .CLK(CLK),
								  .D_IN(m_xactor_to_S_f_wr_data$D_IN),
								  .ENQ(m_xactor_to_S_f_wr_data$ENQ),
								  .DEQ(m_xactor_to_S_f_wr_data$DEQ),
								  .CLR(m_xactor_to_S_f_wr_data$CLR),
								  .D_OUT(m_xactor_to_S_f_wr_data$D_OUT),
								  .FULL_N(m_xactor_to_S_f_wr_data$FULL_N),
								  .EMPTY_N(m_xactor_to_S_f_wr_data$EMPTY_N));

  // submodule m_xactor_to_S_f_wr_resp
  FIFO2 #(.width(32'd2), .guarded(1'd1)) m_xactor_to_S_f_wr_resp(.RST(RST_N),
								 .CLK(CLK),
								 .D_IN(m_xactor_to_S_f_wr_resp$D_IN),
								 .ENQ(m_xactor_to_S_f_wr_resp$ENQ),
								 .DEQ(m_xactor_to_S_f_wr_resp$DEQ),
								 .CLR(m_xactor_to_S_f_wr_resp$CLR),
								 .D_OUT(m_xactor_to_S_f_wr_resp$D_OUT),
								 .FULL_N(m_xactor_to_S_f_wr_resp$FULL_N),
								 .EMPTY_N(m_xactor_to_S_f_wr_resp$EMPTY_N));

  // rule RL_m_rl_wr_addr
  assign CAN_FIRE_RL_m_rl_wr_addr =
	     m_xactor_from_M_f_wr_addr$EMPTY_N &&
	     m_xactor_to_S_f_wr_addr$FULL_N &&
	     m_rg_enabled ;
  assign WILL_FIRE_RL_m_rl_wr_addr = CAN_FIRE_RL_m_rl_wr_addr ;

  // rule RL_m_rl_wr_data
  assign CAN_FIRE_RL_m_rl_wr_data =
	     m_xactor_from_M_f_wr_data$EMPTY_N &&
	     m_xactor_to_S_f_wr_data$FULL_N &&
	     m_rg_enabled ;
  assign WILL_FIRE_RL_m_rl_wr_data = CAN_FIRE_RL_m_rl_wr_data ;

  // rule RL_m_rl_wr_resp
  assign CAN_FIRE_RL_m_rl_wr_resp =
	     m_xactor_to_S_f_wr_resp$EMPTY_N &&
	     m_xactor_from_M_f_wr_resp$FULL_N &&
	     m_rg_enabled ;
  assign WILL_FIRE_RL_m_rl_wr_resp = CAN_FIRE_RL_m_rl_wr_resp ;

  // rule RL_m_rl_rd_addr
  assign CAN_FIRE_RL_m_rl_rd_addr =
	     m_xactor_from_M_f_rd_addr$EMPTY_N &&
	     m_xactor_to_S_f_rd_addr$FULL_N &&
	     m_rg_enabled ;
  assign WILL_FIRE_RL_m_rl_rd_addr = CAN_FIRE_RL_m_rl_rd_addr ;

  // rule RL_m_rl_rd_data
  assign CAN_FIRE_RL_m_rl_rd_data =
	     m_xactor_to_S_f_rd_data$EMPTY_N &&
	     m_xactor_from_M_f_rd_data$FULL_N &&
	     m_rg_enabled ;
  assign WILL_FIRE_RL_m_rl_rd_data = CAN_FIRE_RL_m_rl_rd_data ;

  // rule RL_m_rl_wr_addr_disabled
  assign CAN_FIRE_RL_m_rl_wr_addr_disabled =
	     m_xactor_from_M_f_wr_addr$EMPTY_N &&
	     m_xactor_from_M_f_wr_resp$FULL_N &&
	     !m_rg_enabled ;
  assign WILL_FIRE_RL_m_rl_wr_addr_disabled =
	     CAN_FIRE_RL_m_rl_wr_addr_disabled ;

  // rule RL_m_rl_wr_data_disabled
  assign CAN_FIRE_RL_m_rl_wr_data_disabled =
	     m_xactor_from_M_f_wr_data$EMPTY_N && !m_rg_enabled ;
  assign WILL_FIRE_RL_m_rl_wr_data_disabled =
	     CAN_FIRE_RL_m_rl_wr_data_disabled ;

  // rule RL_m_rl_wr_resp_disabled_drain_S
  assign CAN_FIRE_RL_m_rl_wr_resp_disabled_drain_S =
	     m_xactor_to_S_f_wr_resp$EMPTY_N && !m_rg_enabled ;
  assign WILL_FIRE_RL_m_rl_wr_resp_disabled_drain_S =
	     CAN_FIRE_RL_m_rl_wr_resp_disabled_drain_S ;

  // rule RL_m_rl_rd_addr_disabled
  assign CAN_FIRE_RL_m_rl_rd_addr_disabled =
	     m_xactor_from_M_f_rd_addr$EMPTY_N &&
	     m_xactor_from_M_f_rd_data$FULL_N &&
	     !m_rg_enabled ;
  assign WILL_FIRE_RL_m_rl_rd_addr_disabled =
	     CAN_FIRE_RL_m_rl_rd_addr_disabled ;

  // rule RL_m_rl_rd_data_disabled_drain_S
  assign CAN_FIRE_RL_m_rl_rd_data_disabled_drain_S =
	     m_xactor_to_S_f_rd_data$EMPTY_N && !m_rg_enabled ;
  assign WILL_FIRE_RL_m_rl_rd_data_disabled_drain_S =
	     CAN_FIRE_RL_m_rl_rd_data_disabled_drain_S ;

  // register m_rg_enabled
  assign m_rg_enabled$D_IN = m_enable_enabled ;
  assign m_rg_enabled$EN = 1'd1 ;

  // submodule m_xactor_from_M_f_rd_addr
  assign m_xactor_from_M_f_rd_addr$D_IN = { axi4L_S_araddr, axi4L_S_arprot } ;
  assign m_xactor_from_M_f_rd_addr$ENQ =
	     axi4L_S_arvalid && m_xactor_from_M_f_rd_addr$FULL_N ;
  assign m_xactor_from_M_f_rd_addr$DEQ =
	     WILL_FIRE_RL_m_rl_rd_addr_disabled || WILL_FIRE_RL_m_rl_rd_addr ;
  assign m_xactor_from_M_f_rd_addr$CLR = 1'b0 ;

  // submodule m_xactor_from_M_f_rd_data
  assign m_xactor_from_M_f_rd_data$D_IN =
	     WILL_FIRE_RL_m_rl_rd_data ?
	       m_xactor_to_S_f_rd_data$D_OUT :
	       34'h2AAAAAAAA ;
  assign m_xactor_from_M_f_rd_data$ENQ =
	     WILL_FIRE_RL_m_rl_rd_data || WILL_FIRE_RL_m_rl_rd_addr_disabled ;
  assign m_xactor_from_M_f_rd_data$DEQ =
	     axi4L_S_rready && m_xactor_from_M_f_rd_data$EMPTY_N ;
  assign m_xactor_from_M_f_rd_data$CLR = 1'b0 ;

  // submodule m_xactor_from_M_f_wr_addr
  assign m_xactor_from_M_f_wr_addr$D_IN = { axi4L_S_awaddr, axi4L_S_awprot } ;
  assign m_xactor_from_M_f_wr_addr$ENQ =
	     axi4L_S_awvalid && m_xactor_from_M_f_wr_addr$FULL_N ;
  assign m_xactor_from_M_f_wr_addr$DEQ =
	     WILL_FIRE_RL_m_rl_wr_addr_disabled || WILL_FIRE_RL_m_rl_wr_addr ;
  assign m_xactor_from_M_f_wr_addr$CLR = 1'b0 ;

  // submodule m_xactor_from_M_f_wr_data
  assign m_xactor_from_M_f_wr_data$D_IN = { axi4L_S_wdata, axi4L_S_wstrb } ;
  assign m_xactor_from_M_f_wr_data$ENQ =
	     axi4L_S_wvalid && m_xactor_from_M_f_wr_data$FULL_N ;
  assign m_xactor_from_M_f_wr_data$DEQ =
	     WILL_FIRE_RL_m_rl_wr_data_disabled || WILL_FIRE_RL_m_rl_wr_data ;
  assign m_xactor_from_M_f_wr_data$CLR = 1'b0 ;

  // submodule m_xactor_from_M_f_wr_resp
  assign m_xactor_from_M_f_wr_resp$D_IN =
	     WILL_FIRE_RL_m_rl_wr_resp ?
	       m_xactor_to_S_f_wr_resp$D_OUT :
	       2'd2 ;
  assign m_xactor_from_M_f_wr_resp$ENQ =
	     WILL_FIRE_RL_m_rl_wr_resp || WILL_FIRE_RL_m_rl_wr_addr_disabled ;
  assign m_xactor_from_M_f_wr_resp$DEQ =
	     axi4L_S_bready && m_xactor_from_M_f_wr_resp$EMPTY_N ;
  assign m_xactor_from_M_f_wr_resp$CLR = 1'b0 ;

  // submodule m_xactor_to_S_f_rd_addr
  assign m_xactor_to_S_f_rd_addr$D_IN = m_xactor_from_M_f_rd_addr$D_OUT ;
  assign m_xactor_to_S_f_rd_addr$ENQ = CAN_FIRE_RL_m_rl_rd_addr ;
  assign m_xactor_to_S_f_rd_addr$DEQ =
	     m_xactor_to_S_f_rd_addr$EMPTY_N && axi4L_M_arready ;
  assign m_xactor_to_S_f_rd_addr$CLR = 1'b0 ;

  // submodule m_xactor_to_S_f_rd_data
  assign m_xactor_to_S_f_rd_data$D_IN = { axi4L_M_rresp, axi4L_M_rdata } ;
  assign m_xactor_to_S_f_rd_data$ENQ =
	     axi4L_M_rvalid && m_xactor_to_S_f_rd_data$FULL_N ;
  assign m_xactor_to_S_f_rd_data$DEQ =
	     WILL_FIRE_RL_m_rl_rd_data_disabled_drain_S ||
	     WILL_FIRE_RL_m_rl_rd_data ;
  assign m_xactor_to_S_f_rd_data$CLR = 1'b0 ;

  // submodule m_xactor_to_S_f_wr_addr
  assign m_xactor_to_S_f_wr_addr$D_IN = m_xactor_from_M_f_wr_addr$D_OUT ;
  assign m_xactor_to_S_f_wr_addr$ENQ = CAN_FIRE_RL_m_rl_wr_addr ;
  assign m_xactor_to_S_f_wr_addr$DEQ =
	     m_xactor_to_S_f_wr_addr$EMPTY_N && axi4L_M_awready ;
  assign m_xactor_to_S_f_wr_addr$CLR = 1'b0 ;

  // submodule m_xactor_to_S_f_wr_data
  assign m_xactor_to_S_f_wr_data$D_IN = m_xactor_from_M_f_wr_data$D_OUT ;
  assign m_xactor_to_S_f_wr_data$ENQ = CAN_FIRE_RL_m_rl_wr_data ;
  assign m_xactor_to_S_f_wr_data$DEQ =
	     m_xactor_to_S_f_wr_data$EMPTY_N && axi4L_M_wready ;
  assign m_xactor_to_S_f_wr_data$CLR = 1'b0 ;

  // submodule m_xactor_to_S_f_wr_resp
  assign m_xactor_to_S_f_wr_resp$D_IN = axi4L_M_bresp ;
  assign m_xactor_to_S_f_wr_resp$ENQ =
	     axi4L_M_bvalid && m_xactor_to_S_f_wr_resp$FULL_N ;
  assign m_xactor_to_S_f_wr_resp$DEQ =
	     WILL_FIRE_RL_m_rl_wr_resp_disabled_drain_S ||
	     WILL_FIRE_RL_m_rl_wr_resp ;
  assign m_xactor_to_S_f_wr_resp$CLR = 1'b0 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        m_rg_enabled <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (m_rg_enabled$EN)
	  m_rg_enabled <= `BSV_ASSIGNMENT_DELAY m_rg_enabled$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    m_rg_enabled = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_m_rl_wr_addr_disabled)
	$display("WARNING: rl_wr_addr_disabled: rec'd wr request from M when gate disabled.");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_m_rl_wr_addr_disabled) $write("    ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_m_rl_wr_addr_disabled)
	$write("AXI4_Lite_Wr_Addr { ", "awaddr: ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_m_rl_wr_addr_disabled)
	$write("'h%h", m_xactor_from_M_f_wr_addr$D_OUT[34:3]);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_m_rl_wr_addr_disabled) $write(", ", "awprot: ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_m_rl_wr_addr_disabled)
	$write("'h%h", m_xactor_from_M_f_wr_addr$D_OUT[2:0]);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_m_rl_wr_addr_disabled) $write(", ", "awuser: ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_m_rl_wr_addr_disabled) $write("'h%h", 1'd0, " }");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_m_rl_wr_addr_disabled) $write("\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_m_rl_wr_addr_disabled)
	$display("    Returning error response.");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_m_rl_wr_addr_disabled)
	begin
	  v__h1597 = $stime;
	  #0;
	end
    v__h1591 = v__h1597 / 32'd10;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_m_rl_wr_addr_disabled)
	$display("    %0d: %m", v__h1591);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_m_rl_wr_resp_disabled_drain_S)
	$display("WARNING: rl_wr_resp_disabled: rec'd wr resp from S when gate disabled; ignoring");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_m_rl_wr_resp_disabled_drain_S)
	$display("    (there couldn't have been a request)");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_m_rl_wr_resp_disabled_drain_S)
	begin
	  v__h1761 = $stime;
	  #0;
	end
    v__h1755 = v__h1761 / 32'd10;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_m_rl_wr_resp_disabled_drain_S)
	$display("    %0d: %m", v__h1755);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_m_rl_rd_addr_disabled)
	$display("WARNING: rl_rd_addr_disabled: rec'd rd request from M when gate disabled.");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_m_rl_rd_addr_disabled) $write("    ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_m_rl_rd_addr_disabled)
	$write("AXI4_Lite_Rd_Addr { ", "araddr: ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_m_rl_rd_addr_disabled)
	$write("'h%h", m_xactor_from_M_f_rd_addr$D_OUT[34:3]);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_m_rl_rd_addr_disabled) $write(", ", "arprot: ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_m_rl_rd_addr_disabled)
	$write("'h%h", m_xactor_from_M_f_rd_addr$D_OUT[2:0]);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_m_rl_rd_addr_disabled) $write(", ", "aruser: ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_m_rl_rd_addr_disabled) $write("'h%h", 1'd0, " }");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_m_rl_rd_addr_disabled) $write("\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_m_rl_rd_addr_disabled)
	$display("    Returning error response.");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_m_rl_rd_addr_disabled)
	begin
	  v__h1960 = $stime;
	  #0;
	end
    v__h1954 = v__h1960 / 32'd10;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_m_rl_rd_addr_disabled)
	$display("    %0d: %m", v__h1954);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_m_rl_rd_data_disabled_drain_S)
	$display("WARNING: rl_rd_data_disabled: rec'd rd resp from S when gate disabled; ignoring");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_m_rl_rd_data_disabled_drain_S)
	$display("    (there couldn't have been a request)");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_m_rl_rd_data_disabled_drain_S)
	begin
	  v__h2087 = $stime;
	  #0;
	end
    v__h2081 = v__h2087 / 32'd10;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_m_rl_rd_data_disabled_drain_S)
	$display("    %0d: %m", v__h2081);
  end
  // synopsys translate_on
endmodule  // mkAXI4L_Gate_A

